# 指令系统

## 定义

指令(又称机器指令）:是指示计算机执行某种操作的命令，是计算机运行的最小功能单位。

一台计算机的所有指令的集合构成该机的**指令系统**，也称为**指令集**。

一台计算机只能执行自己指令系统中的指令，不能执行其他系统的指令。

Eg: x86架构、ARM架构

==指令系统是计算机软硬件的界面==

## 指令格式

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902190003099.png" alt="image-20210902190003099" style="zoom:80%;" />

一条指令可能包含0个、1个、2个、3个、4个地址码...

根据地址码数目不同，可以将指令分为零地址指令、一地址指令、二地址指令...

## 指令的分类

### 按地址码数目分类

#### 零地址指令

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902190129296.png" alt="image-20210902190129296" style="zoom:80%;" />

1. **不需要操作数，如空操作、停机、关中断等指令**
2. **堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶**

#### 一地址指令

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902190225407.png" alt="image-20210902190225407" style="zoom:80%;" />

指令含义:

1. OP(A~1~)→A1，如加1、减1、取反、求补等
2. (ACC)OP(A~1~)→ACC，隐含约定的目的地址为ACC

1. 只需要单操作数，如加1、减1、取反、求补等
2. 需要两个操作数，但其中一个操作数隐含在某个寄存器（如隐含在ACC)

> **==注:A~1~指某个主存地址，(A~1~)表示A所指向的地址中的内容==**

==完成一条指令需要2次访存:取指→读A~1~==

#### 二、三地址指令

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902190513162.png" alt="image-20210902190513162" style="zoom:80%;" />

指令含义:(A~1~)OP(A~2~)→>A~1~

1. 常用于需要两个操作数的算术运算、逻辑运算相关指令

==完成一条指令需要访存4次，取指→读A~1~→读A~2~→写A~1~==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902190624272.png" alt="image-20210902190624272" style="zoom:80%;" />

指令含义:(A~1~)OP(A~2~)→A~3~

1. 常用于需要两个操作数的算术运算、逻辑运算相关指令

==完成一条指令需要访存4次，取指→读A~1~→读A~2~→写A~3~==

#### 四地址指令

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902190745275.png" alt="image-20210902190745275" style="zoom:80%;" />

指令含义:(A~1~)OP(A~2~)>A~3~，A~4~=下一条将要执行指令的地址

==完成一条指令需要访存4次，取指→读A~1~→读A~2~→写A~3~==

- **正常情况下:取指令之后PC+1，指向下一条指令**
- **四地址指令:执行指令后，将PC的值修改位A~4~所指地址**

------

**==若指令总长度固定不变，则地址码数量越多，寻址能力越差==**

**==n位地址码的直接寻址范围=2^n^==**

### 按指令长度分类

**指令字长:一条指令的总长度（可能会变)**

**机器字长:CPU进行一次整数运算所能处理的二进制数据的位数（==通常和ALU直接相关==)**

**存储字长:一个存储单元中的二进制代码位数（==通常和MDR位数相同==)**

------

半字长指令、单字长指令、双字长指令 	——指令长度是机器字长的多少倍
指令字长会影响取指令所需时间。如:机器字长=存储字长=16bit，则取一条双字长指令需要两次访存

==**定长指令字结构**:指令系统中所有指令的长度都相等==

==**变长指令字结构**:指令系统中各种指令的长度不等==

### 按操作码长度分类

==**定长操作码**:指令系统中所有指令的操作码长度都相同==

- 优:定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利;
- 缺:指令数量增加时会占用更多固定位，留给表示操作数地址的位数受限。

==**可变长操作码**:指令系统中各指令的操作码长度可变==

- 优:在指令字长有限的前提下仍保持比较丰富的指令种类;
- 缺:增加了指令译码和分析的难度，使控制器的设计复杂化。

**<font color="red">定长指令字结构+可变长操作码→扩展操作码指令格式</font>**

### 按操作类型分类

1. 数据传送

   - LOAD作用:把存储器中的数据放到寄存器中
   - STORE作用:把寄存器中的数据放到存储器中

   > **数据传送类:进行主存与CPU之间的数据传送**

2. 算术逻辑操作

   - 算术:加、减、乘、除、增1、减1、求补、浮点运算、十进制运算
   - 逻辑:与、或、非、异或、位操作、位测试、位清除、位求反

3. 移位操作

   * 算术移位、逻辑移位、循环移位(带进位和不带进位)

4. 转移操作

   * 无条件转移JMP
   * 条件转移 	JZ:结果为0;JO:结果溢出;JC:结果有进位
   * 调用和返回    CALL和RETURN
   * 陷阱(Trap)与陷阱指令
   * 循环指令

   > **程序控制类:改变程序执行的顺序**
   >
   > 程序控制类指令主要包括无条件转移、有条件转移、子程序调用、和返回指令、循环指令等

5. 输入输出操作

   * CPU寄存器与IO端口之间的数据传送(端口即IO接口中的寄存器)

   > **输入输出类（I/0）:进行CPU和I/0设备之间的数据传送**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902192254992.png" alt="image-20210902192254992" style="zoom:80%;" />

## 扩展操作码指令格式

==目的：保持指令字长度不变而增加指令的数量==

**扩展操作码举例**

指令字长为16位，每个地址码占4位:

前4位为基本操作码字段OP，另有3个4位长的地址字段A~1~、A~2~和A~3~

4位基本操作码若全部用于三地址指令，则有16条。==**但至少须将1111留作扩展操作码之用**==，即三地址指令为15条;

11111111留作扩展操作码之用，二地址指令为15条;

11111111 1111留作扩展操作码之用，一地址指令为15条;

零地址指令为16条。

还有其他扩展操作码设计方法。

------

在设计扩展操作码指令格式时，必须注意以下两点:

1. **==不允许短码是长码的前缀==**，即短操作码不能与长操作码的前面部分的代码相同。
2. 各指令的操作码一定不能重复。

通常情况下，对使用频率较高的指令，分配较短的操作码;对使用频率较低的指令，分配较长的操作码，从而尽可能减少指令译码和分析的时间。

**扩展操作码举例**

设指令字长固定为16位，试设计一套指令系统满足:

![image-20210902192930460](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902192930460.png)

## ==指令寻址==

指令寻址：下一条欲执行指令的指令地址 	**==始终由程序计数器PC给出==**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902193232764.png" alt="image-20210902193232764" style="zoom:80%;" />

**顺序寻址**：( PC)+“1”→PC

每次取指令之后,PC一定会自动+1,指向下一条应该执行的指令

**跳跃寻址**：由转移指令指出

**==注:每一条指令的执行都分为“取指令”、“执行指令”两个阶段==**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902193518112.png" alt="image-20210902193518112" style="zoom:80%;" />

## ==数据寻址==

数据寻址确定**本条指令**的地址码指明的<font color="red">**真实地址**</font>

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902193825696.png" alt="image-20210902193825696" style="zoom:80%;" />

**采用不同寻址方式的目的：**

1. 可缩短指令字长，扩大寻址空间，提高编程的灵活性

假设指令字长=机器字长=存储字长 	假设操作数为3

### 直接寻址

直接寻址:指令字中的形式地址A就是操作数的真实地址EA，即EA=A 。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902193947504.png" alt="image-20210902193947504" style="zoom:80%;" />

<font color="red">**一条指令的执行:取指令访存1次，执行指令访存1次，暂不考虑存结果共访存2次**</font>

- 优点:简单，指令执行阶段仅访问一次主存,不需专门计算操作数的地址。
- 缺点:A的位数决定了该指令操作数的寻址范围。操作数的地址不易修改。

### 间接寻址

间接寻址:指令的地址字段给出的形式地址不是操作数的真正地址，而是操作数有效地址所在的存储单元的地址，也就是操作数地址的地址，即EA=(A)。

![image-20210902194231194](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902194231194.png)

<font color="red">**一次间接寻址：一条指令的执行:取指令访存1次，执行指令访存2次，暂不考虑存结果共访存3次**</font>

<font color="red">**两次间接寻址：一条指令的执行:取指令访存1次，执行指令访存3次，暂不考虑存结果共访存4次**</font>

- 优点:可扩大寻址范围(有效地址EA的位数大于形式地址A的位数)。便于编制程序(用间接寻址可以方便地完成子程序返回)。
- 缺点:指令在执行阶段要多次访存(一次间址需两次访存，多次寻址需根据存储字的最高位确定几次访存)。

### 寄存器寻址

寄存器寻址:在指令字中直接给出操作数所在的寄存器编号，即EA =R~i~;，其操作数在由R~i~所指的寄存器内。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902194601500.png" alt="image-20210902194601500" style="zoom:80%;" />

**<font color="red">一条指令的执行:取指令访存1次，执行指令访存0次，暂不考虑存结果共访存1次</font>**

- 优点:指令在执行阶段不访问主存，只访问寄存器,指令字短且执行速度快，支持向量/矩阵运算。
- 缺点:寄存器价格昂贵，计算机中寄存器个数有限。

### 寄存器间接寻址

寄存器间接寻址:寄存器R~i~;中给出的不是一个操作数，而是操作数所在主存单元的地址,
即EA=(R~i~)。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902195023127.png" alt="image-20210902195023127" style="zoom:80%;" />

**<font color="red">一条指令的执行:取指令访存1次执行指令访存1次暂不考虑存结果共访存2次</font>**

* 特点:与一般间接寻址相比速度更快但指令的执行阶段需要访问主存(因为操作数在主存中)。

### 隐含寻址

隐含寻址:不是明显地给出操作数的地址，而是在指令中隐含着操作数的地址。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902195158902.png" alt="image-20210902195158902" style="zoom:80%;" />

- 优点:有利于缩短指令字长。
- 缺点:需增加存储操作数或隐含地址的硬件。

### 立即寻址

立即寻址:形式地址A就是操作数本身，又称为立即数，一般采用补码形式。**<font size=5>==#==</font>表示立即寻址特征。**

**<font color="red">一条指令的执行:取指令访存1次,执行指令访存0次,暂不考虑存结果共访存1次</font>**

- 优点:指令执行阶段不访问主存，指令执行时间最短
- 缺点:A的位数限制了立即数的范围。如A的位数为n，且立即数采用补码时，可表示的数据范围为-2^n-1^~2^n-1^-1

### ==偏移寻址==

#### 基址寻址

基址寻址:将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A,而形成操作数的有效地址，即==EA=(BR)+A。==

> BR——base address register
>
> EA——effective address

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902195908095.png" alt="image-20210902195908095" style="zoom:80%;" />

**==优点:便于程序“浮动”，方便实现多道程序并发运行==**

<font color="red">注:基址寄存器是**面向操作系统**的，其内容由操作系统或管理程序确定。在程序执行过程中，**基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量)。**</font>

<font color="red">当采用通用寄存器作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器,但**其内容仍由操作系统**确定。</font>

**优点:可扩大寻址范围（基址寄存器的位数大于形式地址A的位数)﹔用户不必考虑自己的程序存于主存的哪一空间区域，故有利于多道程序设计，以及可用于编制浮动程序（整个程序在内存里边的浮动)。**

#### 变址寻址

变址寻址:有效地址EA等于指令字中的形式地址A与变址寄存器x的内容相加之和，即==EA=(IX)+A==，其中IX可为变址寄存器（专用），也可用通用寄存器作为变址寄存器。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902200609546.png" alt="image-20210902200609546" style="zoom:80%;" />

<font color="red">注:变址寄存器是**面向用户**的，在程序执行过程中，**变址寄存器的内容可由用户改变(IX作为偏移量)**，**形式地址A不变（作为基地址）**。</font>

**优点：在数组处理过程中，可设定A为数组的首地址,不断改变变址寄存器x的内容，便可很容易形成数组中任一数据的地址，==特别适合编制循环程序==。**

> #### 基址&变址复合寻址
>
> 先基址后变址寻址:EA=(IX)+((BR)+A)

#### 相对寻址

相对寻址:把程序计数器PC的内容加上指令格式中的形式地址A而形成操作数的有效地址，
即**==EA=(PC)+A==**，其中A是相对于PC所指地址的位移量，可正可负，补码表示。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902201211617.png" alt="image-20210902201211617" style="zoom:80%;" />

**优点:这段代码在程序内浮动时==不用更改跳转指令的地址码==**

优点:操作数的地址不是固定的，它随着PC值的变化而变化，并且与指令地址之间总是相差一个固定值，==因此便于程序浮动(一段代码在程序内部的浮动）==。

==**相对寻址广泛应用于转移指令。**==

### 堆栈寻址

堆栈寻址:操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数地址。

堆栈是存储器（或专用寄存器组）中一块特定的按“后进先出（LIFO)”原则管理的存储区，该存储区中被读/写单元的地址是用一个特定的寄存器给出的，**该寄存器称为堆栈指针（SP)** 。

![image-20210902201433103](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902201433103.png)

<font color='blue'>**注：该图访问内存次数的计算未计入取指令步骤**</font>

## CISC和RISC

|                                                   | CISC：Complex Instruction set computer                       | RISC:Reduced instruction set computer                        |
| ------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 设计思路                                          | 一条指令完成一个复杂的基本功能。                             | 一条指令完成一个基本“动作”;<br/>多条指令组合完成一个复杂的基本功能。 |
| 代表                                              | x86架构，主要用于笔记本、台式机等                            | ARM架构，主要用于手机、平板等                                |
| 比如设计一套能实现整数、矩阵加/减/乘运算的指令集: | CISC的思路:除了提供整数的加减乘指令除之外，还提供矩阵的加法指令、矩阵的减法指令、矩阵的乘法指令<br/>一条指令可以由一个专门的电路完成<br>有的复杂指令用纯硬件实现很困难<br/>采用“存储程序”的设计思想，由一个比较通用的电路配合存储部件完成一条指令 | RISC的思路:只提供整数的加减乘指令<br/>一条指令一个电路，电路设计相对简单，功耗更低“并行”、“流水线” |

![image-20210902202127120](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210902202127120.png)

## 高级语言与机器语言的对应

### 编译器、汇编器、连接器

编译器:高级语言程序→汇编语言程序，或高级语言程序→机器语言程序

汇编器:汇编语言程序→机器语言程序，形成多个地址独立的目标模块

链接器:将多个目标模块链接成一个具有完整逻辑地址的装入模块

### X86汇编语言

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211205160827508.png" alt="image-20211205160827508" style="zoom:80%;" />

