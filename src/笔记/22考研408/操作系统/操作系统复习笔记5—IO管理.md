# IO管理

## 概念

“I/O”就是“输入/输出”(Input/Output)
I/O设备就是可以将数据输入到计算机，或者可以接收计算机输出数据的外部设备，属于计算机中的硬件部件。

## 分类

### 按使用特性

#### 人机交互类外部设备

数据传输速度慢

人机交互类外设:鼠标、键盘打印机等―—用于人机交互

#### 存储设备

数据传输速度快

存储设备:移动硬盘、光盘等――用于数据存储

#### 网络通信设备

数据传输速度介于上述二者之间

网络通信设备:调制解调器等―—用于网络通信

### 按传输速率分类

#### 低俗设备

低速设备:鼠标、键盘等——传输速率为每秒几个到几百字节

#### 中速设备

中速设备:如激光打印机等——传输速率为每秒数千至上万个字节

#### 高速设备

高速设备:如磁盘等―—传输速率为每秒数千字节至千兆字节的设备

### 按信息交换的单位分类

#### 块设备

传输速率较高，可寻址，即对它可随机地读/写任一块

块设备:如磁盘等——数据传输的基本单位是“块”

#### 字符设备

传输速率较慢，不可寻址，在输入/输出时常采用==中断驱动方式==

字符设备:鼠标、键盘等——数据传输的基本单位是字符。

## IO控制器

### 概念

I/O设备的==机械部件==主要用来执行具体I/O操作。
如我们看得见摸得着的鼠标/键盘的按钮;显示器的LED屏;移动硬盘的磁臂、磁盘盘面。

I/O设备的==电子部件==通常是一块插入主板扩充槽的印刷电路板。

CPU无法直接控制I/O设备的机械部件，因此I/O设备还要有一个电子部件作为CPU和I/O设备机械部件之间的“中介”，用于实现CPU对设备的控制。
这个电子部件就是==I/O控制器==，又称==设备控制器==。CPU可控制I/O控制器，又由I/O控制器来控制设备的机械部件。

### 功能

#### 接受和识别CPU发出的命令

如CPU发来的read/write命令，I/O控制器中会有相应的**==控制寄存器==**来存放命令和参数

#### 向CPU报告设备的状态

I/O控制器中会有相应的**==状态寄存器==**,用于记录I/O设备的当前状态。如:1表示空闲，0表示忙碌

#### 数据交换

I/O控制器中会设置相应的**==数据寄存器==**。输出时，数据寄存器用于暂存CPU发来的数据，之后再由控制器传送设备。输入时,数据寄存器用于暂存设备发来的数据,之后CPU从数据寄存器中取走数据。

#### 地址识别

类似于内存的地址,为了区分设备控制器中的各个寄存器,也需要给各个寄存器设置一个特定的“地址”。I/O控制器通过CPU提供的“地址”来判断CPU要读/写的是哪个寄存器

### 组成

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211002221716854.png" alt="image-20211002221716854" style="zoom:80%;" />

==值得注意的小细节:==

1. 一个I/O控制器可能会对应多个设备;
2. 数据寄存器、控制寄存器、状态寄存器可能有多个(如:每个控制/状态寄存器对应一个具体的设备），且这些寄存器都要有相应的地址，才能方便CPU操作。有的计算机会让这些寄存器占用内存地址的一部分，称为==**内存映像I/O**==;另一些计算机则采用I/O专用地址，即==**寄存器独立编址**==。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211002221909550.png" alt="image-20211002221909550" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211002221933402.png" alt="image-20211002221933402" style="zoom:80%;" />

## IO控制方式

### 程序直接控制方式

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005105305836.png" alt="image-20211005105305836" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005105408961.png" alt="image-20211005105408961" style="zoom:80%;" />

- 优点：==实现简单==。在读/写指令之后，加上实现循环检查的一系列指令即可（因此才称为“程序直接控制方式”）
- 缺点：==CPU和I/O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态 ，CPU利用率低。==

### 中断驱动方式

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005105548405.png" alt="image-20211005105548405" style="zoom:80%;" />

- 优点：与“程序直接控制方式”相比，在“中断驱动方式”中，I/O控制器会通过中断信号主动报告I/O已完成，CPU不再需要不停地轮询。==CPU和I/O设备可并行工作==，CPU利用率得到明显提升。
- 缺点：每个字在I/O设备与内存之间的传输，都需要经过CPU。而==频繁的中断处理会消耗较多的CPU时间==。

### DMA方式（直接存储器存取）

与“中断驱动方式”相比，==DMA方式（ Direct Memory Access，直接存储器存取==。主要用于块设备的
I/O控制）有这样几个改进：

1. ==数据的传送单位是“块”==。不再是一个字、一个字的传送；
2. 数据的流向是从设备直接放入内存，或者从内存直接到设备。不再需要CPU作为“快递小哥”。
3. 仅在传送一个或多个数据块的开始和结束时，才需要CPU干预。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005110232562.png" alt="image-20211005110232562" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005110259891.png" alt="image-20211005110259891" style="zoom:80%;" />

DR （Data Register，数据寄存器）：暂存从设备到内存，或从内存到设备的数据。
MAR （Memory Address Register，内存地址寄存器）：在输入时，MAR 表示数据应放到内存中的什么位置；输出时 MAR 表示要输出的数据放在内存中的什么位置。
DC （Data Counter，数据计数器）：表示剩余要读/写的字节数。
CR（Command Register，命令/状态寄存器）：用于存放CPU发来的I/O命令，或设备的状态信息。

- 优点：数据传输以“块”为单位，CPU介入频率进一步降低。数据的传输不再需要先经过CPU再写入内存，数据传输效率进一步增加。CPU和I/O设备的并行性得到提升。
- 缺点：CPU每发出一条I/O指令，只能读/写一个或多个连续的数据块。如果要读/写多个离散存储的数据块，或者要将数据分别写到不同的内存区域时，CPU要分别发出多条I/O指令，进行多次中断处理才能完成。

### 通道控制方式

通道:一种==硬件==，可以理解为是“弱鸡版的CPU”。通道可以识别并执行一系列==通道指令==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005110527834.png" alt="image-20211005110527834" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211022181648945.png" alt="image-20211022181648945" style="zoom:80%;" />

- 缺点：实现复杂，需要专门的通道硬件支持
- 优点：==CPU、通道、I/O设备可并行工作，资源利用率很高。==

|                  | 完成一次读/写的过程                                          | CPU干预频率 | 每次I/O的数据传输单位 | 数据流向                        |
| ---------------- | ------------------------------------------------------------ | ----------- | --------------------- | ------------------------------- |
| 程序直接控制方式 | CPU发出I/O命令后需要不断轮询                                 | 极高        | 字                    | 设备→CPU→内存<br/>内存→CPU→设备 |
| 中断控制方式     | CPU发出I/O命令后可以做其他事，<br>本次I/O完成后设备控制器发出中断信号 | 高          | 字                    | 设备→CPU→内存<br/>内存→CPU→设备 |
| DMA方式          | CPU发出I/O命令后可以做其他事，<br>本次I/O完成后DMA控制器发出中断信号 | 中          | 块                    | 设备→内存<br/>内存→设备         |
| 通道控制方式     | CPU发出I/O命令后可以做其他事。<br>通道会执行通道程序以完成I/O，<br>完成后通道向CPU发出中断信号 | 低          | 一组块                | 设备→内存<br/>内存→设备         |

## IO软件层次结构

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005111531046.png" alt="image-20211005111531046" style="zoom:80%;" />

------

### 用户层软件

用户层软件==实现了与用户交互的接口==，用户可直接使用该层提供的、与I/O操作相关的库函数对设备进行操作

用户层软件将用户请求翻译成格式化的I/O请求,并通过“==系统调用==”请求操作系统内核的服务

### 设备独立性软件

设备独立性软件，又称==设备无关性软件==。与设备的硬件特性无关的功能几乎都在这一层实现。

功能：

1. 向上层提供统一的调用接口（如read/write系统调用)

2. 设备的保护（原理类似与文件保护。设备被看做是一种特殊的文件，不同用户对各个文件的访问权限是不一样的，同理，对设备的访问权限也不一样。）

3. 差错处理：设备独立性软件需要对一些设备的错误进行处理

4. 设备的分配与回收

5. 数据缓冲区的管理：可以通过缓冲技术屏蔽设备之间数据交换单位大小和传输速度的差异

6. 建立逻辑设备名到物理设备名的映射关系；据设备类型选择调用相应的驱动程序

   > <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005112120439.png" alt="image-20211005112120439" style="zoom:67%;" />
   >
   > 操作系统系统可以采用两种方式管理==逻辑设备表（LUT):==
   >
   > * 第一种方式，==整个系统只设置一张LUT==，这就意味着所有用户不能使用相同的逻辑设备名，因此这种方式只适用于单用户操作系统。
   > * 第二种方式，==为每个用户设置一张LUT==，各个用户使用的逻辑设备名可以重复，适用于多用户操作系统。系统会在用户登录时为其建立一个用户管理进程，而LUT就存放在用户管理进程的PCB中。

### 设备驱动程序

主要负责对硬件设备的具体控制，将上层发出的一系列命令（如read/write）转化成特定设备“能听得懂”的一系列操作。包括设置设备寄存器;检查设备状态等

==注:驱动程序一般会以一个独立进程的方式存在。==

### 中断处理程序

当I/O任务完成时，I/O控制器会发送一个中断信号，系统会根据中断信号类型找到相应的中断处理程序并执行。中断处理程序的处理流程如下:

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005112422607.png" alt="image-20211005112422607" style="zoom:80%;" />

### 硬件

执行I/O操作,有机械部件、电子部件组成(参考“1/O控制器”小节的视频)

------

理解并记住I/O软件==各个层次之间的顺序==，要能够推理判断某个处理应该是在哪个层次完成的（最常考的是设备独立性软件、设备驱动程序这两层。只需理解一个特点即可:==直接涉及到硬件具体细节、且与中断无关的操作肯定是在设备驱动程序层完成的;没有涉及硬件的、对各种设备都需要进行的管理工作都是在设备独立性软件层完成的==）

## 输入/输出应用程序接口

### **字符设备接口**

get/put系统调用:向字符设备读/写一个字符	如:键盘、打印机，不可“寻址”,每次读1个字符

### **块设备接口**

read/write系统调用:向块设备的读写指针位置读/写多个字符;seek系统调用:修改读写指针位置	如︰磁盘,可“寻址”,每次读/写1个块

### **网络设备接口**

如:网络控制器（网卡)，数据该给谁?

网络设备接口，又称“**网络套接字(socket)接口**”
socket系统调用:创建一个网络套接字，需指明网络协议(TCP? UDP? )																											bind:将套接字绑定到某个本地“端口”																																									connect:将套接字连接到远程地址																																											read/write:从套接字读/写数据

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211205160322927.png" alt="image-20211205160322927" style="zoom:80%;" />

------

### 阻塞IO/非阻塞IO

阻塞I/O:应用程序发出I/O系统调用，进程需转为阻塞态等待。eg:字符设备接口――从键盘读一个字符get

非阻塞I/O:应用程序发出I/O系统调用，系统调用可迅速返回，进程无需阻塞等待。eg:块设备接口一一往磁盘写数据write

## IO核心子系统

属于操作系统的内核部分;即“==I/O系统==”;或称“==I/O核心子系统==”

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005113005208.png" alt="image-20211005113005208" style="zoom:80%;" />

| I/O核心子系统  | 实现功能                                                     |
| -------------- | ------------------------------------------------------------ |
| 用户层软件     | 实现与用户交互的接口，向上提供方便以用的库函数               |
| 设备独立性软件 | 1.向上层提供统一的调用接口（如read/write系统调用）<br>2.设备的保护;<br>3.差错处理;<br>4.设备的分配与回收;<br>5.数据缓冲区管理;<br>6.建立逻辑设备名到物理设备名的映射关系<br>7.根据设备类型选择调用相应的驱动程序.. |
| 设备驱动软件   | 设置设备寄存器、检查设备状态                                 |
| 中断处理程序   | 进行中断处理                                                 |
| 硬件           | 执行I/O操作，有机械部件、电子部件组成                        |



### I/O调度

用某种算法确定一个好的顺序来处理各个I/O请求。

如:磁盘调度（先来先服务算法、最短寻道优先算法、SCAN算法、C-SCAN算法、LOOK算法、C-LOOK算法）。当多个磁盘I/O请求到来时，用某种调度算法确定满足I/O请求的顺序。

### 文件保护

操作系统需要实现==文件保护==功能，不同的用户对各个文件有不同的访问权限（如:只读、读和写等）。
在UNIX系统中，==设备被看做是一种特殊的文件==，每个设备也会有对应的FCB。当用户请求访问某个设备时，系统根据FCB中记录的信息来判断该用户是否有相应的访问权限，以此实现“设备保护”的功能。(参考“文件保护”小节)

### 假脱机技术（SPOOLing技术）

“假脱机技术”，又称“SPOOLing 技术”是用软件的方式模拟脱机技术

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005114650163.png" alt="image-20211005114650163" style="zoom: 67%;" />

要实现SPOOLing技术，==必须要有多道程序技术的支持。==系统会建立“输入进程”和“输出进程”。

- 独占式设备――==只允许各个进程串行使用的设备==。一段时间内只能满足一个进程的请求。
- 共享设备――==允许多个进程“同时”使用的设备==（宏观上同时使用，微观上可能是交替使用）。可以同时满足多个进程的使用请求。

打印机是种“独占式设备”，但是可以用SPOOLing技术改造成“共享设各”

当多个用户进程提出输出打印的请求时，系统会答应它们的请求，但是并不是真正把打印机分配给他们,而是由假脱机管理进程为每个进程做两件事:

1. 在磁盘输出井中为进程申请一个空闲缓冲区（**也就是说，这个缓冲区是在磁盘上的**)，并将要打印的数据送入其中;
2. 为用户进程申请一张空白的打印请求表，并将用户的打印请求填入表中（其实就是用来说明用户的打印数据存放位置等信息的），再将该表挂到假脱机文件队列上。
   当打印机空闲时，输出进程会从文件队列的队头取出一张打印请求表，并根据表中的要求将要打印的数据从输出井传送到输出缓冲区，再输出到打印机进行打印。用这种方式可依次处理完全部的打印任务

SPOOLing技术可以把一台物理设备虚拟成逻辑上的多台设备，可将独占式设备改造成共享设备。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005115047039.png" alt="image-20211005115047039" style="zoom:80%;" />

### 设备的分配与回收

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005115646341.png" alt="image-20211005115646341" style="zoom:80%;" />

------

#### 设备分配时应考虑的因素

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211005115236185.png" alt="image-20211005115236185" style="zoom:80%;" />

设备的固有属性可分为三种:独占设备、共享设备、虚拟设备。

- **独占设备**——一个时段只能分配给一个进程（如打印机）
- **共享设备**——可同时分配给多个进程使用（如磁盘)，各进程往往是宏观上同时共享使用设备，而微观上交替使用。
- **虚拟设备**——采用SPOOLing 技术将独占设备改造成虚拟的共享设备，可同时分配给多个进程使用（如采用SPOOLing技术实现的共享打印机)

设备的分配算法:
先来先服务、优先级高者优先、短任务优先……

从进程运行的安全性上考虑，设备分配有两种方式:

- 安全分配方式:为进程分配一个设备后就将进程阻塞，本次I/O完成后才将进程唤醒。

  > 一个时段内每个进程只能使用一个设备
  >
  > 优点:破坏了“请求和保持”条件，不会死锁
  > 缺点:对于一个进程来说，CPU和I/O设备只能串行工作

- 不安全分配方式:进程发出I/O请求后，系统为其分配I/O设备，进程可继续执行，之后还可以发出新的I/O请求。只有某个I/O请求得不到满足时才将进程阻塞。

  > 一个进程可以同时使用多个设备
  >
  > 优点:进程的计算任务和/O任务可以并行处理，使进程迅速推进																											缺点:有可能发生死锁（死锁避免、死锁的检测和解除)

#### 静态分配与动态分配

* 静态分配:进程运行前为其分配全部所需资源，运行结束后归还资源	`破坏了“请求和保持”条件，不会发生死锁`
* 动态分配:进程运行过程中动态申请设备资源

#### 设备分配管理中的数据结构

#### 设备分配的步骤

#### 设备分配步骤的改进方法

### 缓冲区管理

#### 缓冲区概念

缓冲区是一个存储区域，==可以由专门的硬件寄存器组成==，==也可利用内存作为缓冲区==
使用硬件作为缓冲区的成本较高，容量也较小，一般仅用在对速度要求非常高的场合（如存储器管理中所用的联想寄存器，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）
一般情况下，==更多的是利用内存作为缓冲区==，“设备独立性软件”的缓冲区管理就是要组织管理好这些缓冲区

#### 缓冲区的作用

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206170120227.png" alt="image-20211206170120227" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206170135683.png" alt="image-20211206170135683" style="zoom:80%;" />

#### 分类

##### 单缓冲区

假设某用户进程请求某种块设备读入若干块的数据。若采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块）。
**注意:当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出;当缓冲区为空时，可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206170523789.png" alt="image-20211206170523789" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206170435335.png" alt="image-20211206170435335" style="zoom:67%;" />



##### 双缓冲区

假设某用户进程请求某种块设备读入若干块的数据。若采用双缓冲的策略，操作系统会在主存中为其分配两个缓冲区（若题目中没有特别说明，一个缓冲区的大小就是一个块)
**双缓冲题目中，假设初始状态为:工作区空，其中一个缓冲区满，另一个缓冲区空**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206170551904.png" alt="image-20211206170551904" style="zoom:80%;" />

==**单缓冲区和双缓冲区的区别**==：

显然，若两个相互通信的机器只设置单缓冲区，在任一时刻只能实现数据的单向传输。

若两个相互通信的机器设置双缓冲区，则同一时刻可以实现双向的数据传输。

==注:管道通信中的“管道”其实就是缓冲区。要实现数据的双向传输，必须设置两个管道==

##### 循环缓冲区

将多个**大小相等**的缓冲区链接成一个**循环队列**。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206170851061.png" alt="image-20211206170851061" style="zoom:80%;" />

##### 缓冲池

缓冲池由系统中共用的缓冲区组成。这些缓冲区按使用状况可以分为:空缓冲队列、装满输入数据的缓冲队列（输入队列)、装满输出数据的缓冲队列（输出队列）。
另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区:用于收容输入数据的工作缓冲区(hin)、用于提取输入数据的工作缓冲区(sin)、用于收容输出数据的工作缓冲区(hout）、用于提取输出数据的工作缓冲区(sout)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206171027996.png" alt="image-20211206171027996" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211206171053973.png" alt="image-20211206171053973" style="zoom:80%;" />

### 设备驱动程序接口

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211205160532380.png" alt="image-20211205160532380" style="zoom:80%;" />‘

<font color=red>**操作系统规定好设备驱动程序的接口标准，各厂商必须按要求开发设备驱动程序**</font>

不同的操作系统，对设备驱动程序接口的标准各不相同。

设备厂商必须根据操作系统的接口要求，开发相应的设备驱动程序，设备才能被使用
