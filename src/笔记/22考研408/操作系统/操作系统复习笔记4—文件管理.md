# 文件管理

## 文件的基本概念

**文件——就是一组有意义的信息/数据集合**

一个文件有哪些属性?

**文件名**:由创建文件的用户决定文件名，主要是为了方便用户找到文件，==同一目录下不允许有重名文件==。								**标识符**:一个系统内的各文件标识符唯一，对用户来说毫无可读性,因此标识符只是操作系统用于区分各个文件的一种内部名称。
**类型**:指明文件的类型
**位置**:文件存放的路径（让用户使用）、在外存中的地址(操作系统使用，对用户不可见)
**大小**:指明文件大小
**创建时间**、**上次修改时间**																																											**文件所有者信息**																																															**保护信息**:对文件进行保护的访问控制信息

文件内部的数据应该怎样组织起来?

- **无结构文件（如文本文件）**——由一些二进制或字符流组成，又称“流式文件”
- **有结构文件（如数据库表）**——由==一组相似的记录组成==,又称“记录式文件”

操作系统应该向上提供哪些功能？

![image-20210930205459101](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930205459101.png)

其他需要由操作系统实现的文件管理功能

- 文件共享:使多个用户可以共享使用一个文件
- 文件保护:如何保证不同的用户对文件有不同的操作权限下

## 文件的逻辑结构

所谓的“逻辑结构”，==**就是指在用户看来**==，文件内部的数据应该是如何组织起来的。而“物理结构”指的是在操作系统看来，文件的数据是如何存放在外存中的。

### 无结构文件

按文件是否有结构分类，可以分为无结构文件、有结构文件两种。
**无结构文件**:文件内部的数据就是一系列二进制流或字符流组成。又称“**流式文件**”。如:Windows操作系统中的.txt文件。

### 有结构文件

**有结构文件**:由一组相似的记录组成，又称“**记录式文件**”。每条记录又若干个数据项组成。如:数据库表文件。一般来说，每条记录有一个数据项可作为**关键字**。根据各条记录的长度（占用的存储空间）是否相等，又可分为**定长记录**和**可变长记录**两种。

#### 顺序文件

**顺序文件**:文件中的记录一个接一个地顺序排列（逻辑上)，记录可以是==定长的或可变长的==。各个记录在物理上可以==顺序存储或链式存储==。

- 顺序存储——逻辑上相邻的记录物理上也相邻（类似于顺序表）
- 链式存储——逻辑上相邻的记录物理上不一定相邻（类似于链表）

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930210101745.png" alt="image-20210930210101745" style="zoom:80%;" />

#### 索引文件

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930210624877.png" alt="image-20210930210624877" style="zoom:80%;" />

**索引表**本身是**定长记录的顺序文件**。因此可以快速找到第i个记录对应的索引项。
可将关键字作为索引号内容，若按关键字顺序排列，则还可以支持按照关键字折半查找。
每当要增加/删除一个记录时,需要对索引表进行修改。由于索引文件有很快的检索速度，因此==主要用于对信息处理的及时性要求比较高的场合。==

另外，**可以用不同的数据项建立多个索引表**。如:学生信息表中，可用关键字“学号”建立一张索引表。也可用“姓名”建立一张索引表。这样就可以根据“姓名”快速地检索文件了。

#### 顺序索引文件

**思考索引文件的缺点**:每个记录对应一个索引表项，因此索引表可能会很大。比如:文件的每个记录平均只占8B，而每个索引表项占32个字节，那么索引表都要比文件内容本身大4倍，这样对存储空间的利用率就太低了。

索引顺序文件是索引文件和顺序文件思想的结合。索引顺序文件中，同样会为文件建立一张索引表，但不同的是:并不是每个记录对应一个索引表项，而是**一组记录对应一个索引表项**。

**<font color='red' size=4>检索效率分析</font>**

若一个顺序文件有10000个记录，则根据关键字检索文件，只能从头开始顺序查找（这里指的并不是定长记录、顺序结构的顺序文件），平均须查找5000个记录。
若采用索引顺序文件结构，可把10000个记录分为√10000= 100组，每组100个记录。则需要先顺序查找索引表找到分组（共100个分组，因此索引表长度为100，平均需要查50次)，找到分组后，再在分组中顺序查找记录（每个分组100个记录，因此平均需要查50次）。可见，采用索引顺序文件结构后，平均查找次数减少为50+50 = 100次。

## 文件目录

### FCB 文件控制块

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930211156571.png" alt="image-20210930211156571" style="zoom:80%;" />

FCB的有序集合称为“文件目录”，一个FCB就是一个文件**目录项**。FCB中包含了文件的**基本信息**（**文件名**、**物理地址**、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）。

==最重要,最基本==的还是==文件名、文件存放的物理地址。== `FCB 实现了文件名和文件之间的映射。使用户（用户程序）可以实现“按名存取”`

需要对目录进行哪些操作?
**搜索**:当用户要使用一个文件时，系统要根据文件名搜索目录，找到该文件对应的目录项															                     **创建文件**:创建一个新文件时，需要在其所属的目录中增加一个目录项
**删除文件**:当删除一个文件时，需要在目录中删除相应的目录项
**显示目录**:用户可以请求显示目录的内容，如显示该目录中的所有文件及相应属性
**修改目录**:某些文件属性保存在目录中，因此这些属性变化时需要修改相应的目录项(如:文件重命名)

### 目录结构

#### ~~单级目录结构~~

早期操作系统并不支持多级目录，整个系统中只建立一张目录表，每个文件占一个目录项。

单级目录实现了“按名存取”，但是==不允许文件重名==。

显然，单级目录结构不适用于多用户操作系统。

#### ~~两级目录结构~~

早期的多用户操作系统，采用两级目录结构。分为==主文件目录==(MFD，Master File Directory)和==用户文件目录==（UFD，User File Directory) 。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930211822829.png" alt="image-20210930211822829" style="zoom:80%;" />

#### 多级目录结构（树形目录结构）

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930211937367.png" alt="image-20210930211937367" style="zoom:80%;" />

用户(或用户进程）要访问某个文件时要用文件路径名标识文件，文件路径名是个字符串。各级目录之间用“/”隔开。==从根目录出发的路径==称为==绝对路径==。

例如，此时已经打开了“照片”的目录文件，也就是说，这张目录表已调入内存，那么可以把它设置为“当前目录”。当用户想要访问某个文件时，可以使用==从当前目录出发==的“==相对路径==”。

可见，引入“==当前目录==”和“==相对路径==”后，磁盘I/O的次数减少了。这就提升了访问文件的效率。

#### ~~无环图目录结构~~

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930212206712.png" alt="image-20210930212206712" style="zoom:80%;" />

==可以用不同的文件名指向同一个文件==，甚至可以指向同一个目录（共享同一目录下的所有内容）。

需要为==每个共享结点设置一个共享计数器==，用于记录此时有多少个地方在共享该结点。用户提出删除结点的请求时，只是删除该用户的FCB、并使==共享计数器减1==，并不会直接删除共享结点。==只有共享计数器减为0时，才删除结点==。

注意:共享文件不同于复制文件。在==共享文件中，由于各用户指向的是同一个文件因此只要其中一个==
==用户修改了文件数据，那么所有用户都可以看到文件数据的变化。==

### 目录的操作

* create系统调用，创建目录:创建一个新目录文件，为之分配磁盘空间，并修改父目录文件中的内容***（如增加新建文件的FCB）***

  > 新建目录的中**FCB个数不为0**，因为会==默认创建.和..FCB，用于指向当前目录和父目录==

* delete系统调用，删除目录:只有空目录可以删除

* opendir系统调用，打开目录:和打开普通文件一样，只是将指向该目录文件的FCB读入内存而已，并不是把目录文件的数据全部读入内存

* readdir系统调用，读目录:必须在打开目录后才能读目录，返回目录文件中的下一个目录项rename系统调用，重命名:给目录重命名，本质上是修改指向该目录文件的FCB

* link系统调用，建立硬链接:将指定的文件与目录建立硬链接，该系统调用导致指定目录中多了一个FCB，而指定文件的inode共享计数器+1

* unlink系统调用，解除硬链接，指定文件的 inode共享计数器-1，若计数器=0，则删除文件数据

### 索引节点（FCB的改进）

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930212521659.png" alt="image-20210930212521659" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930212538251.png" alt="image-20210930212538251" style="zoom:80%;" />

当找到文件名对应的目录项时，才需要将索引结点调入内存，索引结点中记录了文件的各种信息，包括文件在外存中的存放位置，根据“存放位置”即可找到文件。
存放==在外存中==的索引结点称为“==磁盘索引结点==”，当索引结点==放入内存==后称为“==内存索引结点==”。相比之下==内存索引结点中需要增加一些信息==，比如:文件是否被修改、此时有几个进程正在访问该文件等。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930212823469.png" alt="image-20210930212823469" style="zoom:80%;" />

### 文件元数据

文件元数据（ metadata) :即文件属性，记录在文件FCB中

如:
文件创建者创建时间
上一次修改时间
文件格式―—ppt ? txt? exe? avi?
隐藏标志―—0/1表示是否隐藏不显示?																																									系统标志―—0/1表示是否是系统文件?																																									只读标志―—0/1表示是否只读?
文件大小――多少个B?

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202171228713.png" alt="image-20211202171228713" style="zoom:80%;" />

## 文件保护

### 口令保护

为文件设置一个“口令”(如: abc112233)，用户请求访问该文件时必须提供“口令”

==口令一般存放在文件对应的FCB或索引结点中==。用户访问文件前需要先输入“口令”，操作系统会将用户提供的口令与FCB中存储的口令进行对比，如果正确，则允许该用户访问文件

- 优点:保存口令的空间开销不多，验证口令的时间开销也很小。
- 缺点:正确的“口令”存放在系统内部，不够安全。

### 加密保护

使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解密。

- 优点:保密性强，不需要在系统中存储“密码”
- 缺点:编码/译码,或者说加密/解密要花费一定时间。

### 访问控制

在每个文件的FCB（或索引结点）中增加一个==访问控制列表==（Access-Control List,ACL)，该表中记录了各个用户可以对该文件执行哪些操作。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930213107897.png" alt="image-20210930213107897" style="zoom:80%;" />

精简的访问列表:以“组”为单位，标记各“组”用户可以对文件执行哪些操作。																				如:分为系统管理员、文件主、文件主的伙伴、其他用户几个分组。

<font color='red'>通常由用户访问权限和文件属性共同限制</font>

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930213316339.png" alt="image-20210930213316339" style="zoom:80%;" />

## 文件共享

### 基于索引结点的共享方式（硬链接)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930213530108.png" alt="image-20210930213530108" style="zoom:80%;" />

索引结点中设置一个链接计数变量count，用于表示链接到本索引结点上的用户目录项数。
若count =2，说明此时有两个用户目录项链接到该索引结点上，或者说是有两个用户在共享此文件。若某个用户决定“删除”该文件，则只是要把用户目录中与该文件对应的目录项删除，且索引结点的count值减1。
若count>0，说明还有别的用户要使用该文件，暂时不能把文件数据删除，否则会导致指针悬空。											当count=0时系统负责删除文件

### 基于符号链的共享方式(软链接)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930213828763.png" alt="image-20210930213828763" style="zoom:80%;" />

## 文件的物理结构

### 连续分配

==连续分配==方式要求==每个文件在磁盘上占有一组连续的块==。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930214216783.png" alt="image-20210930214216783" style="zoom:80%;" />

文件目录中记录存方的起始块号和长度（总共占用几个块)

可以直接算出逻辑块号对应的物理块号，因此连续分配支持顺序访问和直接访问（即随机访问)

- 优点：连续分配的文件在顺序读/写时速度最快
- 缺点：
  1. 物理上采用连续分配的文件不方便拓展。
  2. 物理上采用连续分配存储空间利用率低，会产生难以利用的磁盘碎片

### 链接分配

==链接分配==采取离散分配的方式，可以为文件分配离散的磁盘块。分为==隐式链接==和==显式链接==两种。

#### 隐式链接

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930214652197.png" alt="image-20210930214652197" style="zoom:80%;" />

结论:采用==链式分配(隐式链接）==方式的文件，==只支持顺序访问，不支持随机访问==，查找效率低。另外，指向下一个盘块的指针也需要耗费少量的存储空间。

结论:采用==隐式链接的链接分配方式==，==很方便文件拓展==。另外，所有的空闲磁盘块都可以被利用，==不会有碎片问题,外存利用率高。==

- 优点:很方便文件拓展，不会有碎片问题，外存利用率高。
- 缺点:只支持顺序访问，不支持随机访问，查找效率低，指向下一个盘块的指针也需要耗费少量的存储空间。

#### 显示链接

把用于链接文件各物理块的指针显式地存放在一张表中。即文件分配表（FAT，File Allocation Table)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930214833637.png" alt="image-20210930214833637" style="zoom:80%;" />

注意:==**一个磁盘仅设置一张FAT。开机时，将FAT读入内存，并常驻内存**==。FAT的各个表项在物理上连续存储，且每一个表项长度相同，因此“物理块号”字段可以是隐含的。

结论:采用==链式分配（显式链接）==方式的文件，支持顺序访问，也==支持随机访问（想访问i号逻辑块时，并不需要依次访问之前的0~ i-1号逻辑块）==，由于块号转换的过程不需要访问磁盘，因此相比于隐式链接来说，访问速度快很多。

- 优点:很方便文件拓展，不会有碎片问题，外存利用率高，并且==支持随机访问==。相比于隐式链接来说，地址转换时==不需要访问磁盘，因此文件的访问效率更高==。
- 缺点:文件分配表的需要占用一定的存储空间。

### 索引分配

==索引分配==允许文件离散地分配在各个磁盘块中，系统会==为每个文件建立一张索引表==，索引表中==记录了文件的各个逻辑块对应的物理块==（索引表的功能类似于内存管理中的页表――建立逻辑页面到物理页之间的映射关系）。索引表存放的磁盘块称为==索引块==。文件数据存放的磁盘块称为==数据块==。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930215316924.png" alt="image-20210930215316924" style="zoom:80%;" />

==注:在显式链接的链式分配方式中，文件分配表FAT是一个磁盘对应一张。而索引分配方式中，索引表是一个文件对应一张==。

可见，索引分配方式可以==支持随机访问。文件拓展也很容易实现==（只需要给文件分配一个空闲块，并增加一个索引表项即可)

**<font color='red' size=4>如果一个索引块装不下整张索引表怎么办？</font>**

①==链接方案==:如果索引表太大，一个索引块装不下，那么可以将多个索引块链接起来存放。

②==多层索引==:建立多层索引（原理类似于**多级页表**)。使第一层索引块指向第二层的索引块。还可根据文件大小的要求再建立第三层、第四层索引块。

③==混合索引==:多种索引分配方式的结合。例如，一个文件的顶级索引表中，既包含直接地址索引（直接指向数据块），又包含一级间接索引（指向单层索引表)、还包含两级间接索引（指向两层索引表)。

==超级超级超级重要考点:==

①要会根据多层索引、混合索引的结构计算出文件的最大长度(Key:各级索引表最大不能超过一个块)

②要能自己分析访问某个数据块所需要的读磁盘次数(Key: FCB中会存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块。每次读入下一级的索引块都需要一次读磁盘操作。另外，要==注意题目条件——顶级索引块是否已调入内存==)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930215903052.png" alt="image-20210930215903052" style="zoom:80%;" />

## 文件存储空间管理

### 空闲表法

==适用于“连续分配方式”==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930220139719.png" alt="image-20210930220139719" style="zoom:80%;" /><img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930220156906.png" alt="image-20210930220156906" style="zoom:80%;" />

如何分配磁盘块:与内存管理中的动态分区分配很类似，为一个文件分配连续的存储空间。同样可采用==首次适应、最佳适应、最坏适应==等算法来决定要为文件分配哪个区间。

### 空闲链表法

空闲盘块链——以盘块为单位组成一条空闲链
空闲盘区链——以盘区为单位组成一条空闲链

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930220431514.png" alt="image-20210930220431514" style="zoom:75%;" /><img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930220447145.png" alt="image-20210930220447145" style="zoom:75%;" />

### 位示图法

位示图:每个二进制位对应一个盘块。在本例中，“0”代表盘块空闲，“1”代表盘块已分配。位示图一般用连续的“字”来表示，如本例中一个字的字长是16位，字中的每一位对应一个盘块。因此==可以用（字号，位号）对应一个盘块号。当然有的题目中也描述为（行号，列号）==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930220708607.png" alt="image-20210930220708607" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930220735692.png" alt="image-20210930220735692" style="zoom:80%;" />

### 成组链接法

空闲表法、空闲链表法不适用于大型文件系统，因为空闲表或空闲链表可能过大。UNIX系统中采用了成组链接法对磁盘空闲块进行管理。

==文件卷的目录区==中专门用一个磁盘块作为“==超级块==”，当系统启动时需要将==超级块读入内存==。并且要保证内存与外存中的“超级块”数据一致。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930221111396.png" alt="image-20210930221111396" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930221600684.png" alt="image-20210930221600684" style="zoom:80%;" />

## 文件的基本操作

### 创建文件

进行Create系统调用时，需要提供的几个主要参数:

1. 所需的外存空间大小（如:一个盘块，即1KB)
2. 文件存放路径（“D:/Demo”)
3. 文件名(这个地方默认为“新建文本文档.txt”)

操作系统在处理Create系统调用时，主要做了两件事:

1. ==在外存中找到文件所需的空间==（结合上小节学
   习的空闲链表法、位示图、成组链接法等管理策略，找到空闲空间)
2. 根据文件存放路径的信息找到该目录对应的目录文件（此处就是D:/Demo目录），在目录中==创建该文件对应的目录项==。目录项中包含了文件名、文件在外存中的存放位置等信息。

### 删除文件

进行Delete系统调用时，需要提供的几个主要参数:

1. 文件存放路径（“D:/Demo”)
2. 文件名(“test.txt”)

操作系统在处理Delete系统调用时，主要做了几件事:

1. 根据文件存放路径找到相应的目录文件，从目
   录中==找到文件名对应的目录项==。
2. 根据该目录项记录的文件在外存的存放位置、文件大小等信息，==回收文件占用的磁盘块==。(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理)
3. 从目录表中==删除文件对应的目录项==。

### 打开文件

在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数:

1. 文件存放路径（“D:/Demo”)
2. 文件名（“test.txt”)
3. 要对文件的操作类型（如:r只读;rw读写等)

操作系统在处理open系统调用时，主要做了几件事:

1. 根据文件存放路径找到相应的目录文件，从目录中==找到文件名对应的的目录项==，并检查该用户是否有指定的操作权限。
2. ==将目录项复制到内存中的“打开文====件表”中==。并将对应表目的编号返回给用户。之后==用户使用打开文件表的编号来指明要操作的文件。==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222204847.png" alt="image-20210930222204847" style="zoom:80%;" />

### 关闭文件

进程使用完文件后，要“关闭文件”
操作系统在处理Close系统调用时，主要做了几件事:

1. 将进程的打开文件表相应表项删除
2. 回收分配给该文件的内存空间等资源
3. 系统打开文件表的打开计数器count减1，若count =0，则删除对应表项。

### 读文件

进程使用read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据（如:读入1KB）、指明读入的数据要放在内存中的什么位置。

操作系统在处理read系统调用时，会从读指针指向的外存中,将用户指定大小的数据读入用户指定的内存区域中。

### 写文件

进程使用write系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中,只需要提供文件在打开文件表中的索引号即可），还需要指明要写出多少数据（如:写出1KB)、写回外存的数据放在内存中的什么位置

操作系统在处理write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222433953.png" alt="image-20210930222433953" style="zoom:80%;" />

## 文件系统的层次结构

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222539177.png" alt="image-20210930222539177" style="zoom:80%;" />

用一个例子来辅助记忆文件系统的层次结构:
假设某用户请求删除文件“D:/工作目录/学生信息.xlsx”的最后100条记录。

1. 用户需要通过操作系统提供的接口发出上述请求——用户接口
2. 由于用户提供的是文件的存放路径，因此需要操作系统一层一层地查找目录，找到对应的目录项——文件目录系统
3. 不同的用户对文件有不同的操作权限，因此为了保证安全，需要检查用户是否有访问权限――存取控制模块（存取控制验证层)
4. 验证了用户的访问权限之后，需要把用户提供的“记录号”转变为对应的逻辑地址――逻辑文件系统与文件信息缓冲区
5. 知道了目标记录对应的逻辑地址后，还需要转换成实际的物理地址――物理文件系统
6. 要删除这条记录，必定要对磁盘设备发出请求――设备管理程序模块
7. 删除这些记录后，会有一些盘块空闲，因此要将这些空闲盘块回收――辅助分配模块

### 文件在外存中的结构

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202170205424.png" alt="image-20211202170205424" style="zoom:80%;" />

每个分区就是一个独立的文件系统，可以采用不同的方案实现――空闲分区管理、文件物理结构、目录实现方式（完整的FCB?文件元数据和索引节点分离?)

### 文件在内存中的结构

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202170309876.png" alt="image-20211202170309876" style="zoom:80%;" />

#### open系统调用过程

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202170529147.png" alt="image-20211202170529147" style="zoom:80%;" />

## 虚拟文件系统

**为用户进程提供统一的接口**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202173850907.png" alt="image-20211202173850907" style="zoom:80%;" />

虚拟文件系统的特点：

1. 向上层用户进程提供统一标准的系统调用接口，屏蔽底层具体文件系统的实现差异

2. VFS要求下层的文件系统必须实现某些规定的函数功能，*如: open/read/write。一个新的文件系统想要在某操作系统上被使用，就必须满足该操作系统VFS的要求*

3. 每打开一个文件，VFS就在主存中新建一个vnode，用统一的数据结构表示文件，无论该文件存储在哪个文件系统。

   > 注意：
   >
   > * vnode只存在于主存中，而inode既会被调入主存，也会在外存中存储。
   >
   > * 打开文件后，创建vnode，并将文件信息复制到vnode中，vnode的功能指针指向具体文件系统的函数功能。
   >
   >   <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202173917523.png" alt="image-20211202173917523" style="zoom:80%;" />

## 文件系统的挂载

文件系统挂载(mounting)，即文件系统安装/装载――如何将一个文件系统挂载到操作系统中?

如：插入U盘时，windows系统会将U盘挂载到根目录，mac系统会挂载到volumes

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202174417488.png" alt="image-20211202174417488" style="zoom:80%;" />

文件系统挂载要做的事：

1. 在VFS中注册新挂载的文件系统。内存中的挂载表（mount table）包含每个文件系统的相关信息，包括文件系统类型、容量大小等。
2. 新挂载的文件系统，要向VFS提供一个函数地址列表
3. 将新文件系统加到挂载点(mountpoint) ，也就是将新文件系统挂载在某个父目录下

## 磁盘

### 结构

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222719668.png" alt="image-20210930222719668" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222743037.png" alt="image-20210930222743037" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222803214.png" alt="image-20210930222803214" style="zoom:80%;" />

可用==(柱面号，盘面号，扇区号）==来定位任意一个“磁盘块”。在“文件的物理结构”小节中，我们经常提到文件数据存放在外存中的几号块,这个块号就可以转换成（(柱面号，盘面号，扇区号)的地址形式。

可根据该地址读取一个“块”

1. 根据“柱面号”移动磁臂，让磁头指向指定柱面;
2. 激活指定盘面对应的磁头;
3. 磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读/写。

- 磁头可以移动的称为==活动头磁盘==。磁臂可以来回伸缩来带动磁头定位磁道

  <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930222940820.png" alt="image-20210930222940820" style="zoom:80%;" />

- 磁头不可移动的称为==固定头磁盘==。这种磁盘中每个磁道有一个磁头

  <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930223031369.png" alt="image-20210930223031369" style="zoom:80%;" />

- 盘片可以更换的称为==可换盘磁盘==
- 盘片不可更换的称为==固定盘磁盘==

### 磁盘调度算法

一次磁盘读/写操作需要的时间

==寻找时间（(寻道时间）==T~s~:在读/写数据前，将磁头移动到指定磁道所花的时间。
①启动磁头臂是需要时间的。假设耗时为s;
②移动磁头也是需要时间的。假设磁头匀速移动，每跨越一个磁道耗时为m，总共需要跨越n条磁道。则:
==寻道时间T~s~=s+ m*n==

==延迟时间T~R~:==通过旋转磁盘，使磁头定位到目标扇区所需要的时间。设磁盘转速为r（单位:转/秒，或转/分），则
==平均所需的延迟时间TR=(1/2)*(1/r)= 1/2r==	`1/r就是转一圈需要的时间。找到目标扇区平均需要转半圈，因此再乘以1/2`

传输时间T~t~:从磁盘读出或向磁盘写入数据所经历的时间，假设磁盘转速为r，此次读/写的字节数为b，每个磁道上的字节数为N。则:
==传输时间T~t~= (1/r)* (b/N) = b/(rN)==

总的平均存取时间T~a~=T~s~ + 1/2r + b/(rN)

> 延迟时间和传输时间都与磁盘转速相关，且为线性相关。而转速是硬件的固有属性,因此操作系统也无法优化延迟
> 时间和传输时间
>
> 但是操作系统的磁盘调度算法会直接影响寻道时间

#### 先来先服务算法（FCFS)

根据进程请求访问磁盘的先后顺序进行调度。

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道
按照FCFS的规则，按照请求到达的顺序，磁头需要依次移动到55、58、39、18、90、160、150、38、184号磁道

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930223803167.png" alt="image-20210930223803167" style="zoom:80%;" />

磁头总共移动了45+3+19+21+72+70+10+112+146=498个磁道响应一个请求平均需要移动498/9= 55.3个磁道（平均寻找长度)

- 优点:公平;如果请求访问的磁道比较集中的话，算法性能还算过的去
- 缺点:如果有大量进程竞争使用磁盘，请求访问的磁道很分散，则FCFS在性能上很差，寻道时间长。

#### 最短寻找时间优先(SSTF)

SSTF 算法会优先处理的磁道是与当前磁头最近的磁道。可以保证每次的寻道时间最短，但是并不能保证总的寻道时间最短。（其实就是贪心算法的思想，只是选择眼前最优，但是总体未必最优)

假设磁头的初始位置是100号磁道，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930223945881.png" alt="image-20210930223945881" style="zoom:80%;" />

磁头总共移动了(100-18)+ (184-18)= 248个磁道
响应一个请求平均需要移动248/9=27.5个磁道（平均寻找长度)

- 优点:性能较好，平均寻道时间短
- 缺点:==可能产生“饥饿”现象==

#### 扫描算法（SCAN)

SSTF算法会产生饥饿的原因在于:磁头有可能在一个小区域内来回来去地移动。为了防止这个问题，可以规定，==只有磁头移动到最外侧磁道的时候才能往内移动，移动到最内侧磁道的时候才能往外移动==。这就是==扫描算法（SCAN）==的思想。由于磁头移动的方式很像电梯，因此也叫==电梯算法。==

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且==此时磁头正在往磁道号增大的方向移动==，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930224217308.png" alt="image-20210930224217308" style="zoom:80%;" />
磁头总共移动了(200-100)+ (200-18)= 282个磁道
响应一个请求平均需要移动282/9 = 31.3个磁道（平均寻找长度)

- 优点:性能较好，平均寻道时间较短，==不会产生饥饿现象==
- 缺点:
  - 只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。
  - SCAN算法对于各个位置磁道的响应频率不平均（如:假设此时磁头正在往右移动且刚处理过90号磁道，那么下次处理90号磁道的请求就需要等磁头移动很长一段距离;而响应了184号磁道的请求之后，很快又可以再次响应184号磁道的请求了)

#### LOOK 调度算法

扫描算法(SCAN）中，只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了。==LOOK调度算法==就是为了解决这个问题，==如果在磁头移动方向上已经没有别的请求，就可以立即改变磁头移动方向==。(边移动边观察，因此叫LOOK)

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且==此时磁头正在往磁道号增大的方向移动==，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

![image-20210930224515352](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930224515352.png)

响应一个请求平均需要移动250/9= 27.5个磁道（平均寻找长度)

优点:比起SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

#### 循环扫描算法(C-SCAN)

SCAN算法对于各个位置磁道的响应频率不平均，而C-SCAN算法就是为了解决这个问题。规定只有磁头朝某个特定方向移动时才处理磁道访问请求，而==返回时直接快速移动至起始端而不处理任何请求==。

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且==此时磁头正在往磁道号增大的方向移动==，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930224637656.png" alt="image-20210930224637656" style="zoom:80%;" />

磁头总共移动了(200-100)+(200-0) + (90-0)= 390个磁道
响应一个请求平均需要移动390/9 = 43.3个磁道（平均寻找长度）

优点:比起SCAN来，对于各个位置磁道的响应频率很平均。
缺点:只有到达最边上的磁道时才能改变磁头移动方向，事实上，处理了184号磁道的访问请求之后就不需要再往右移动磁头了;并且，磁头返回时其实只需要返回到18号磁道即可，不需要返回到最边缘的磁道。另外，比起SCAN算法来，平均寻道时间更长。

#### C-LOOK 调度算法

C-SCAN算法的主要缺点是只有到达最边上的磁道时才能改变磁头移动方向，并且磁头返回时不一定需要返回到最边缘的磁道上。C-LOOK算法就是为了解决这个问题。如果磁头移动的方向上已经没有磁道访问请求了，就可以立即让磁头返回，并且磁头只需要返回到有磁道访问请求的位置即可。

假设某磁盘的磁道为0~200号，磁头的初始位置是100号磁道，且==此时磁头正在往磁道号增大的方向移动==，有多个进程先后陆续地请求访问55、58、39、18、90、160、150、38、184号磁道

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930224814310.png" alt="image-20210930224814310" style="zoom:80%;" />

磁头总共移动了(184-100)+(184-18)+(90-18)= 322个磁道
响应一个请求平均需要移动322/9= 35.8个磁道（平均寻找长度)

优点:比起 C-SCAN算法来，不需要每次都移动到最外侧或最内侧才改变磁头方向，使寻道时间进一步缩短

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930224916693.png" alt="image-20210930224916693" style="zoom:80%;" />

### 减少的磁盘延迟时间的方法

#### 交替编号

磁头读入一个扇区数据后需要一小段时间处理，如果逻辑上相邻的扇区在物理上也相邻，则读入几个连续的逻辑扇区，可能需要很长的“延迟时间”

若采用交替编号的策略，即让逻辑上相邻的扇区在物理上有一定的间隔，可以使读取连续的逻辑扇区所需要的延迟时间更小。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930225116237.png" alt="image-20210930225116237" style="zoom:80%;" />

#### 错位命名

![image-20210930225408557](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930225408557.png)

#### 磁盘地址结构的设计

思考:为什么?
磁盘的物理地址是（柱面号，盘面号，扇区号)而不是（盘面号，柱面号，扇区号)

若物理地址结构是（柱面号，盘面号，扇区号），且需要连续读取物理地址(000, 00,000)~ (000,01,111）的扇区:			(000, 00,000） ~( 000, 00,111)由盘面0的磁头读入数据之后再读取物理地址相邻的区域，即
(000, 01, 000)~ ( 000, 01,111) ，由于柱面号/磁道号相同，只是盘面号不同，因此不需要移动磁头臂。只需要激活相邻盘面的磁头即可

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930225431499.png" alt="image-20210930225431499" style="zoom:80%;" />

### 操作系统引导

#### 初始化

磁盘初始化:
Step 1:进行==低级格式化(物理格式化）==，将磁盘的各个磁道==划分为扇区==。一个扇区通常可分为头、数据区域（如512B大小)、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CRC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误)
Step 2:将磁盘分区，每个分区由若干柱面组成（即分为我们熟悉的C盘、D盘、E盘)
Step 3:进行==逻辑格式化==，创建文件系统。包括创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表)

##### 原始磁盘

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202164225461.png" alt="image-20211202164225461" style="zoom:80%;" />

##### 物理格式化

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202164306179.png" alt="image-20211202164306179" style="zoom:80%;" />

物理格式化，即低级格式化――划分扇区，检测坏扇区，并用备用扇区替换坏扇

##### 逻辑格式化

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202164415282.png" alt="image-20211202164415282"  />

完成各分区的文件系统初始化注:逻辑格式化后，灰色部分就有实际数据了，白色部分还没有数据

==每个分区可以是不同的文件系统==，且每个分区都会有引导块，但未必都安装了操作系统。如果==没安装操作系统==，则该分区的==引导块为空==。



**引导块**：Bios把引导块导入内存，引导块把根目录读入内存，通过根目录把操作系统内核文件导入内存，进而完成初始化

**超级块**：用来寻找磁盘中所有的空闲块，当系统启动时需要将==超级块读入内存==。并且要保证内存与外存中的“超级块”数据一致。

**空闲空间管理**：判断某个盘块是否空闲

**i结点区**：==索引节点==

**根目录**：文件系统必须从根目录出发

#### 引导过程

![image-20211202165907470](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202165907470.png)

计算机开机时需要进行一系列初始化的工作，这些初始化工作是通过执行==初始化程序（自举程序）==完成的

~~初始化程序可以放在ROM（只读存储器）中。ROM中的数据在出厂时就写入了，并且==以后不能再修改==~~

ROM中只存放很小的“自举装入程序”
开机时计算机先运行“自举装入程序”，通过执行该程序就可找到引导块，并将完整的“自举程序”读入内存，完成初始化

完整的自举程序放在磁盘的启动块（即引导块/启动分区）上，启动块位于磁盘的固定位置。

操作系统引导:

1. CPU从一个特定主存地址开始，取指令，执行ROM中的引导程序（自举程序)
2. 将磁盘的第一块――主引导记录读入内存，执行磁盘引导程序，检查分区表
3. 从主分区（即安装了操作系统的分区）读入分区引导块，执行该引导块的程序
4. 从根目录下找到完整的操作系统初始化程序并执行（完成“开机”的一系列动作)

#### 坏块的管理

对于简单的磁盘，可以在逻辑格式化时（建立文件系统时)）对整个磁盘进行坏块检查，标明哪些扇区是坏扇区，比如:在FAT表上标明。（在这种方式中，==坏块对操作系统不透明==)

对于复杂的磁盘,磁盘控制器（磁盘设备内部的一个硬件部件）会维护一个坏块链表。
在磁盘出厂前进行低级格式化（物理格式化）时就将坏块链进行初始化。
会保留一些“==备用扇区==”，用于替换坏块。这种方案称为扇区备用。且这种处理方式中，==坏块对操作系统透明==。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210930225937210.png" alt="image-20210930225937210" style="zoom:80%;" />

