# 内存管理

## 基础知识

内存的作用：内存可存放数据。程序执行前需要先放到内存中才能被CPU处理――缓和CPU与硬盘之间的速度矛盾

### 装入的三种方式

#### 绝对装入（单道程序阶段）

==绝对装入==:在编译时，如果知道程序将放到内存中的哪个位置，编译程序将产生绝对地址的目标代码。装入程序按照装入模块中的地址，将程序和数据装入内存。**==绝对装入只适用于单道程序环境。==**

#### 静态重定位（多道批处理操作系统）

==静态重定位:==又称==可重定位装入==。编译、链接后的装入模块的地址都是从0开始的，指令中使用的地址、数据存放的地址都是相对于起始地址而言的逻辑地址。可根据内存的当前情况，将装入模块装入到内存的适当位置。装入时对地址进行“==重定位==”，将逻辑地址变换为物理地址（地址变换是在装入时一次完成的)。

静态重定位的特点是在一个作业装入内存时==，必须分配其要求的全部内存空间==，如果没有足够的内存，就不能装入该作业。作业一旦进入内存后，==在运行期间就不能再移动==，也不能再申请内存空间。

#### 动态重定位（现代操作系统）

==动态重定位==:又称==动态运行时装入==。编译、链接后的装入模块的地址都是从0开始的。装入程序把装入模块装入内存后，并不会立即把逻辑地址转换为物理地址，而是==把地址转换推迟到程序真正要执行时才进行==。因此装入内存后所有的地址依然是逻辑地址。这种方式需要一个==重定位寄存器==的支持。

### 从写程序到程序运行

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210928223655254.png" alt="image-20210928223655254" style="zoom:80%;" />

- **编译**:由编译程序将用户源代码编译成若干个目标模块（编译就是把高级语言翻译为机器语言)
- **链接:**由链接程序将编译后形成的一组目标模块，以及所需库函数链接在一起，形成一个完整的装入模块
- **装入（装载）**:由装入程序将装入模块装入内存运行

### 链接的三种方式



1. **静态链接**:在程序运行之前,先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块),之后不再拆开。
2. **装入时动态链接**:将各目标模块装入内存时，边装入边链接的链接方式。
3. **运行时动态链接**:在程序执行中需要该目标模块时,才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210928223922668.png" alt="image-20210928223922668" style="zoom:80%;" />

## 内存管理的概念

1. 内存空间的分配与回收
2. 内存空间的扩展
3. 地址转换
4. 内存保护
4. 内存共享

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210928224400124.png" alt="image-20210928224400124" style="zoom:80%;" />

## 内存空间的分配与回收

### 连续分配管理方式

### 单一连续分配

在单一连续分配方式中，内存被分为==系统区==和==用户区==。系统区通常位于内存的低地址部分，用于存放操作系统相关数据;用户区用于存放用户进程相关数据。

内存中==只能有一道用户程序==，用户程序独占整个用户区空间。

- **优点**:实现简单;**无外部碎片;**可以采用覆盖技术扩充内存;**不一定需要采取内存保护**（eg:早期的PC操作系统MS-DOS）。
- **缺点**:只能用于单用户、单任务的操作系统中;**有内部碎片**;存储器利用率极低。

### 固定分区分配

20世纪60年代出现了支持多道程序的系统，为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将整个**用户空间**划分为**若干个固定大小的分区**，在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929205737593.png" alt="image-20210929205737593" style="zoom:80%;" />

- 分区大小相等:缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合
- 分区大小不等:增加了灵活性，可以满足不同大小的进程需求。根据常在系统中运行的作业大小情况进行划分



操作系统需要建立一个数据结构―一分区说明表，来实现各个分区的分配与回收。每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929205916263.png" alt="image-20210929205916263" style="zoom:80%;" />

- 优点:实现简单，无外部碎片。
- 缺点:
  1. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能; 
  2. 会产生内部碎片，内存利用率低。

### 动态分区分配

==动态分区分配==又称为==可变分区分配==。这种分配方式==不会预先划分内存分区==，而是在进程装入内存时,==根据进程的大小动态地建立分区==，并使分区的大小正好适合进程的需要。因此系统分区的大小和数目是可变的。(eg:假设某计算机内存大小为64MB，系统区8MB，用户区共56 MB.….)

1.系统要用什么样的数据结构记录内存的使用情况?

- 空闲分区表

  <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929210251162.png" alt="image-20210929210251162" style="zoom:80%;" />

- 空闲分区链

  <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929210310025.png" alt="image-20210929210310025" style="zoom:80%;" />

2.当很多个空闲分区都能满足需求时，应该选择哪个分区进行分配?

#### 首次适应算法

**算法思想**:每次都从低地址开始查找，找到第一个能满足大小的空闲分区。

**如何实现**==:**空闲分区以地址递增的次序排列**==。每次分配内存时顺序查找==**空闲分区链**==（或==**空闲分区表**==)，找到大小能满足要求的第一个空闲分区。

#### 最佳适应算法

**算法思想:**由于动态分区分配是一种连续分配方式，为各进程分配的空间必须是连续的一整片区域。因此为了保证当“大进程”到来时能有连续的大片空间，可以尽可能多地留下大片的空闲区，即，优先使用更小的空闲区。

**如何实现:**空闲分区**==按容量递增次序链接==**。每次分配内存时顺序查找**==空闲分区链==**（或**==空闲分区表==**），找到大小能满足要求的第一个空闲分区。

**缺点**:==每次都选最小的分区进行分配,会留下越来越多的、很小的、难以利用的内存块。因此这种方法会产生很多的外部碎片。==

#### 最坏适应算法

又称==最大适应算法（Largest Fit)==

**算法思想:**为了解决最佳适应算法的问题――即留下太多难以利用的小碎片，可以在每次分配时优先使用最大的连续空闲区，这样分配后剩余的空闲区就不会太小，更方便使用。

**如何实现:**空闲分区**==按容量递减次序链接==**。每次分配内存时顺序查找**==空闲分区链==**（或**==空闲分区表==**），找到大小能满足要求的第一个空闲分区。

**缺点**:==每次都选最大的分区进行分配，虽然可以让分配后留下的空闲区更大，更可用，但是这种方式会导致较大的连续空闲区被迅速用完。如果之后有“大进程”到达，就没有内存分区可用了。==

#### 邻近适应算法

**算法思想:**首次适应算法每次都从链头开始查找的。这可能会导致低地址部分出现很多小的空闲分区，而每次分配查找时，都要经过这些分区，因此也增加了查找的开销。如果每次都从上次查找结束的位置开始检索，就能解决上述问题。

**如何实现**:空闲分区以地址递增的顺序排列(可排成一个循环链表）。每次分配内存时**==从上次查找结束的位置开始==**查找**==空闲分区链==**（或**==空闲分区表==**)，找到大小能满足要求的第一个空闲分区。

首次适应算法每次都要从头查找，每次都需要检索低地址的小分区。但是这种规则也决定了当低地址部分有更小的分区可以满足需求时，会更有可能用到低地址部分的小分区，也会更有可能把高地址部分的大分区保留下来(最佳适应算法的优点）

邻近适应算法的规则可能会导致无论低地址、高地址部分的空闲分区都有相同的概率被使用，也就导致了高地址部分的大分区更可能被使用，划分为小分区，最后导致无大分区可用（最大适应算法的缺点)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929211749573.png" alt="image-20210929211749573" style="zoom:80%;" />

**<font color='red'>四种算法中，首次适应算法的效果反而更好</font>**

------

3.如何进行分区的分配与回收操作?

- 情况一:回收区的后面有一个相邻的空闲分区
- 情况二:回收区的前面有一个相邻的空闲分区
- 情况三:回收区的前、后各有一个相邻的空闲分区
- 情况四:回收区的前、后都没有相邻的空闲分区

> 如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。
>
> 可以通过==紧凑（拼凑,Compaction）技术==来解决外部碎片。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929210722927.png" alt="image-20210929210722927" style="zoom:80%;" />

### 非连续分配管理方式

#### ==基本分页存储管理方式==

##### 概念

将内存空间分为一个个==大小相等的分区==（比如:每个分区4KB)，每个分区就是一个==“页框”（页框=页帧=内存块=物理块=物理页面）==。每个页框有一个编号，即==“页框号”(页框号=页帧号=内存块号=物理块号=物理页号)==，页框号==从0开始==。

将进程的逻辑地址空间也分为==与页框大小相等==的一个个部分，每个部分称为一个==“页”==或==“页面”==。每个页面也有一个编号,即==“页号”==，页号也是==从0开始==。

操作系统==以页框为单位==为各个进程分配内存空间。进程的每个页面分别放入一个页框中。也就是说，进程的==页面==与内存的==页框==有==一一对应==的关系。

各个页面不必连续存放，可以放到不相邻的各个页框中。

为了能知道进程的每个页面在内存中存放的位置，操作系统要为每个进程建立一张**==页表==**。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929212752973.png" alt="image-20210929212752973" style="zoom:80%;" />

1. 一个进程对应一张页表
2. 进程的每个页面对应一个页表项
3. 每个==页表项==由“页号”和“块号”组成 `页号可以是隐含的，不占存储空间`
4. 页表记录进程==页面==和实际存放的==内存块==之间的==映射关系==

- ------

  ==页号===逻辑地址/页面长度(取除法的整数部分)

- ==页内偏移量===逻辑地址%页面长度(取除法的余数部分)

- 逻辑地址可以拆分为(页号，页内偏移量)	通过页号查询页表，可知页面在内存中的起始地址

- 页面在内存中的起始地址+页内偏移量=实际的物理地址

分页存储管理的逻辑地址结构如下所示:<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929213257635.png" alt="image-20210929213257635" style="zoom:80%;" />

- ==如果有K位表示“页内偏移量”，则说明该系统中一个页面的大小是2^K^个内存单元==
- ==如果有M位表示“页号”，则说明在该系统中，一个进程最多允许有2^M^个页面==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929213435580.png" alt="image-20210929213435580" style="zoom:80%;" />

##### 地址变换机构

###### 基本地址变换机构

基本地址变换机构可以借助进程的页表将逻辑地址转换为物理地址。
通常会在系统中设置一个==页表寄存器（PTR）==，存放==页表在内存中的起始地址F==和==页表长度M==。进程未执行时，页表的始址和页表长度==放在进程控制块( PCB）==中，当进程被调度时，操作系统内核会把它们放到页表寄存器中。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929213907015.png" alt="image-20210929213907015" style="zoom:80%;" />

设页面大小为L，逻辑地址A到物理地址E的变换过程如下:

1. 计算页号Р和页内偏移量w（如果用十进制数手算，则P=A/L，W=A%L;但是在计算机实际运行时，逻辑地址结构是固定不变的，因此计算机硬件可以更快地得到二进制表示的页号、页内偏移量)
2. 比较页号P和页表长度M，若P>M，则产生越界中断，否则继续执行。（注意:页号是从O开始的，而页表长度至少是1，因此==P=M时也会越界==)
3. 页表中页号P对应的==页表项地址=页表起始地址F+页号P*页表项长度==，取出该页表项内容b，即为内存块号。(注意区分页表项长度、页表长度、页面大小的区别。==页表长度==指的是这个页表中总共有几个页表项，即总共有几个页;==页表项长度==指的是每个页表项占多大的存储空间;页面大小指的是一个页面占多大的存储空间)
4. 计算E= b*L+W，用得到的物理地址E去访存。（如果内存块号、页面偏移量是用二进制表示的，那么把二者拼接起来就是最终的物理地址了)

> 理论上，页表项长度为3B即可表示内存块号的范围，但是，为了方便页表的查询常常会让一个页表项占更多的字节，使得==每个页面恰好可以装得下整数个页表项。==
>
> ==进程页表通常是装在连续的内存块中的==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929214226009.png" alt="image-20210929214226009" style="zoom:80%;" />

###### 具有块表的地址变换机构

==快表==，又称==联想寄存器(TLB==，translation lookaside buffer )，是一种==访问速度比内存快很多==的高速缓存(==**TLB不是内存!**==)，用来存放==最近访问的页表项的副本==，可以加速地址变换的速度。与此对应，内存中的页表常称为==慢表==。<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929214524169.png" alt="image-20210929214524169" style="zoom:80%;" />

1. CPU给出逻辑地址，由某个硬件算得页号、页内偏移量，将页号与快表中的所有页号进行比较。
2. 如果找到匹配的页号，说明要访问的页表项在快表中有副本，则直接从中取出该页对应的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，==访问==该物理地址对应的==内存单元==。因此，若==快表命中==，则访问某个逻辑地址仅需==一次访存==即可。
3. 如果没有找到匹配的页号，则需要访问内存中的页表，找到对应页表项，得到页面存放的内存块号，再将内存块号与页内偏移量拼接形成物理地址，最后，==访问==该物理地址对应的==内存单元==。因此,==若快表未命中==，则访问某个逻辑地址需要==两次访存==（==注意:在找到页表项后，应同时将其存入快表==，以便后面可能的再次访问。但若快表已满，则必须按照一定的算法对旧的页表项进行替换)

> 例:某系统使用基本分页存储管理，并采用了具有快表的地址变换机构。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少?
> (1+100)\*0.9+ (==1==+100+100)\*0.1===111== us
> 有的系统支持<font color='red'>**快表和慢表同时查找**</font>，如果是这样，平均耗时应该是																		(1+100)\*0.9 +(100+100)\*0.1===110.9== us
> 若未采用快表机制，则访问一个逻辑地址需要<br>==100+100= 200us==

> ==时间局部性==:如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行;如果某个数据被访问过，不久之后该数据很可能再次被访问。(因为程序中存在大量的循环）
> ==空间局部性==:一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问。(因为很多数据在内存中都是连续存放的)
>
> 上小节介绍的==基本地址变换机构==中，每次要访问一个逻辑地址，都需要==查询内存中的页表==。由于局部性原理，==可能连续很多次查到的都是同一个页表项==。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929215152930.png" alt="image-20210929215152930" style="zoom:80%;" />

##### 多级页表

根据页号查询页表的方法:K号页对应的页表项存放位置=页表始址+K*4要在==所有的页表项都连续存放==的基础上才能用这种方法找到页表项

根据局部性原理可知，很多时候，==进程在一段时间内只需要访问某几个页面就可以正常运行了==。因此==没有必要让整个页表都常驻内存==。

- ==问题一:页表必须连续存放，因此当页表很大时，需要占用很多个连续的页框。==

  可将长长的页表进行分组，使每个内存块刚好可以放入一个分组(比如上个例子中，页面大小4KB，每个页表项4B，每个页面可存放1K个页表项，因此每1K个连续的页表项为一组，每组刚好占一个内存块，再讲各组离散地放到各个内存块中)
  另外，要为离散分配的页表再建立一张页表，称为==页目录表，==或称==外层页表==，或称==顶层页表==

  地址变换：

  1. 按照地址结构将逻辑地址拆分成三部分
  2. 从PCB中读出页目录表始址，再根据一级页号查页目录表，找到下一级页表在内存中的存放位置
  3. 根据二级页号查表，找到最终想访问的内存块号
  4. 结合页内偏移量得到物理地址

- 问题二:没有必要让整个页表常驻内存，因为进程在一段时间内可能只需要访问某几个特定的页面。

  可以在需要访问页面时才把页面调入内存（虚拟存储技术）。可以在页表项中增加一个标志位，用于表示该页面是否已经调入内存

  若想访问的页面不在内存中，则产生缺页中断（内中断），然后将目标页面从外存调入内存

> 需要注意的几个细节
>
> 1. 若采用多级页表机制，则==各级页表的大小不能超过一个页面==
>
>    <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929220052180.png" alt="image-20210929220052180" style="zoom:80%;" />
>
> 2. 两级页表的访存次数分析（假设没有快表机构)
>
>    第一次访存:访问内存中的页目录表
>    第二次访存:访问内存中的二级页表																																	第三次访存:访问目标内存单元

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929220151830.png" alt="image-20210929220151830" style="zoom:80%;" />

#### 分段存储管理方式

进程的地址空间:按照程序==自身的逻辑==关系==划分为若干个段==，每个段都有一个段名（在低级语言中，程序员使用段名来编程），==每段从0开始编址==
内存分配规则:以段为单位进行分配，==每个段在内存中占据连续空间==，但==各段之间可以不相邻==。

由于是按逻辑功能模块划分，用户==编程更方便，程序的可读性更高==

分段系统的逻辑地址结构由段号（段名）和段内地址（段内偏移量〉所组成。如:<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929220451427.png" alt="image-20210929220451427" style="zoom:80%;" />

<font color='red'>段号的位数决定了每个进程最多可以分几个段																																		段内地址位数决定了每个段的最大长度是多少</font>

程序分多个段，各段离散地装入内存，为了保证程序能正常运行，就必须能从物理内存中找到各个逻辑段的存放位置。为此，需为每个进程建立一张段映射表，简称“==段表==”。

1. 每个段对应一个段表项，其中记录了该段在内存中的==起始位置==（又称
   “基址”）和==段的长度==。
2. ==各个段表项的长度是相同的==。例如:某系统按字节寻址，采用分段存
   储管理，逻辑地址结构为(段号16位,段内地址16位），因此用16位即可表示最大段长。物理内存大小为4GB（可用32位表示整个物理内存地址空间）。因此，可以让每个段表项占16+32= 48位，即6B。由于段表项长度相同，因此==段号可以是隐含的，不占存储空间==。若段表存放的起始地址为M，则K号段对应的段表项存放的地址为M+K*6

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929221625301.png" alt="image-20210929221625301" style="zoom:80%;" />

> 分段、分页管理的对比
>
> 页是信息的==物理单位==。分页的主要目的是为了实现离散分配，提高内存利用率。分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的。
> 段是信息的==逻辑单位==。分段的主要目的是更好地满足用户需求。一个段通常包含着一组属于一个逻辑模块的信息。分段对用户是可见的，用户编程时需要显式地给出段名。
>
> 页的大小固定且==由系统决定==。																																						段的长度却不固定，==决定于用户编写的程序==。
>
> 分页的用户进程==地址空间是一维的==，程序员只需给出一个记忆符即可表示一个地址。
> 分段的用户进程==地址空间是二维的==，程序员在标识一个地址时，既要给出段名，也要给出段内地址。
>
> ==分段比分页更容易实现信息的共享和保护。==
>
> 不能被修改的代码称为==纯代码==或==可重入代码==（**不属于临界资源**），这样的代码是可以共享的。可修改的代码是不能共享的（比如，有一个代码段中有很多变量，各进程并发地同时访问可能造成数据不一致)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929222326846.png" alt="image-20210929222326846" style="zoom:80%;" />

#### 段页式存储管理方式

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929222510798.png" alt="image-20210929222510798" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929222551889.png" alt="image-20210929222551889" style="zoom:80%;" />

段页式系统的逻辑地址结构由段号、页号、页内地址（页内偏移量）组成。如:<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929222634989.png" alt="image-20210929222634989" style="zoom:80%;" />

<font color='red'>段号的位数决定了每个进程最多可以分几个段																																		页号位数决定了每个段最大有多少页
																																						页内偏移量决定了页面大小、内存块大小是多少</font>

> “分段”对用户是可见的，程序员编程时需要显式地给出段号、段内地址。而将各段“分页”对用户是不可见的。系统会根据段内地址自动划分页号和页内偏移量。
> 因此段页式管理的==地址结构是二维的==。

每个段对应一个段表项，每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。每个段表项长度相等,段号是隐含的。

每个页面对应一个页表项，每个页表项由页号、页面存放的内存块号组成。每个页表项长度相等，页号是隐含的

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929223018543.png" alt="image-20210929223018543" style="zoom:80%;" />

![image-20210929223054570](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929223054570.png)

## 内存空间的扩充

### ~~覆盖与交换~~

**覆盖技术的思想**:将程序分为多个段(多个模块)。常用的段常驻内存，不常用的段在需要时调入内存。

内存中分为**一个“固定区”**和**若干个“覆盖区”**。

需要常驻内存的段放在**“固定区”**中，**调入后就不再调出**（除非运行结束)

不常用的段放在**“覆盖区”**，**需要用到时调入内存，用不到时调出内存**

**交换（对换）技术的设计思想**:内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存（进程在内存与磁盘间动态调度)

暂时换出外存等待的进程状态为挂起状态（挂起态，suspend挂起态又可以进一步细分为就绪挂起、阻塞挂起两种状态<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210928224634560.png" alt="image-20210928224634560" style="zoom:80%;" />

1. 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分。文件
   区主要用于存放文件，主要追求存储空间的利用率，因此对文件区空间的管理采用离散分配方式;对换区空间只占磁盘空间的小部分，被换出的进程数据就存放在对换区。由于对换的速度直接影响到系统的整体速度，因此对换区空间的管理主要追求换入换出速度，因此通常对换区采用连续分配方式(学过文件管理章节后即可理解）。总之，对换区的I/o速度比文件区的更快。
2. 交换通常在许多进程运行且内存吃紧时进行，而系统负荷降低就暂停。例如:在
   发现许多进程运行时经常发生缺页，就说明内存紧张，此时可以换出一些进程;如果缺页率明显下降，就可以暂停换出。
3. 可优先换出阻塞进程;可换出优先级低的进程;为了防止优先级低的进程在被调
   入内存后很快又被换出，有的系统还会考虑进程在内存的驻留时间...

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210928224745629.png" alt="image-20210928224745629" style="zoom:80%;" />

### 虚拟内存

#### 概念

- ==一次性==:==作业必须一次性全部装入内存后才能开始运行==。这会造成两个问题:

  - 作业很大时,不能全部装入内存，导致==大作业无法运行==;
  - 当大量作业要求运行时，由于内存无法容纳所有作业，因此只有少量作业能运行，导致==多道程序并发度下降。==

- ==驻留性==:一旦作业被装入内存，就==会一直驻留在内存==中，直至作业运行结束。事实上，在一个时间段内，只需要访问作业的一小部分数据即可正常运行，这就导致了内存中会驻留大量的、暂时用不到的数据，浪费了宝贵的内存资源。

  <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929223643141.png" alt="image-20210929223643141" style="zoom:80%;" />基于局

部性原理，在程序装入时，可以将程序中==很快会用到的部分装入内存，暂时用不到的部分留在外存==，就可以让程序开始执行。

在程序执行过程中，当所访问的==信息不在内存时==，由==操作系统负责将所需信息从外存调入内存==，然后继续执行程序。
若内存空间不够，由==操作系统==负责将内存中==暂时用不到的信息换出到外存==。
在操作系统的管理下，在用户看来似乎有一个比实际内存大得多的内存，这就是==虚拟内存==

虚拟内存有一下三个主要特征:

- ==多次性==:无需在作业运行时一次性全部装入内存，而是允许被分成多次调入内存。
- ==对换性==:在作业运行时无需一直常驻内存，而是允许在作业运行过程中，将作业换入、换出。
- ==虚拟性==:从逻辑上扩充了内存的容量，使用户看到的内存容量，远大于实际的容量。

虚拟内存技术，允许一个作业分多次调入内存。如果采用连续分配方式，会不方便实现。因此，虚拟内存的实现需要建立在==离散分配==的内存管理方式基础上。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929224029747.png" alt="image-20210929224029747" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929224113645.png" alt="image-20210929224113645" style="zoom:80%;" />

#### 请求分页管理方式

==请求分页==存储管理与==基本分页==存储管理的主要区别:
在程序执行过程中，当所==访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存==，然后继续执行程序。
若内存空间不够，由操作系统负责==将内存中暂时用不到的信息换出到外存==。

与基本分页管理相比，请求分页管理中，为了实现“请求调页”，操作系统需要知道每个页面是否已经调入内存;如果还没调入，那么也需要知道该页面在外存中存放的位置。

当内存空间不够时，要实现“页面置换”，操作系统需要通过某些指标来决定到底换出哪个页面;有的页面没有被修改过，就不用再浪费时间写回外存。有的页面修改过，就需要将外存中的旧数据覆盖，因此，操作系统也需要记录各个页面是否被修改的信息。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929224322322.png" alt="image-20210929224322322" style="zoom:80%;" /><img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929224353079.png" alt="image-20210929224353079" style="zoom:80%;" />

- 在请求分页系统中，每当要访问的==页面不在内存==时，便产生一个==缺页中断==，然后由操作系统的缺页==中断处理程序处理中断。==
- 此时==缺页的进程阻塞==，放入阻塞队列，调页==完成后再将其唤醒==，放回就绪队列。
- 如果内存中有空闲块，则为进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项。
- 如果内存中==没有空闲块==，则==由页面置换算法选择一个页面淘汰==，若该页面在内存期间==被修改过==，则要将其==写回外存==。未修改过的页面不用写回外存。

> **缺页中断**是因为当前执行的指令想要访问的目标页面未调入内存而产生的，因此属于**内中断**
> 一条指令在执行期间，**可能产生多次缺页中断**。(如: copy A to B，即将逻辑地址A中的数据复制到逻辑地址B，而A、B属于不同的页面，则有可能产生两次中断）
>
> <img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929224702488.png" alt="image-20210929224702488" style="zoom:80%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929224810469.png" alt="image-20210929224810469" style="zoom:80%;" />

#### 页面置换算法

##### 最佳置换算法（OPT)

最佳置换算法（OPT，Optimal):每次选择==淘汰的页面==将是==以后永不使用==，或者==在最长时间内不再被访问的页面==，这样可以保证最低的缺页率。

##### 先进先出置换算法（FIFO)

先进先出置换算法(FIFO):每次选择==淘汰的页面==是==最早进入内存的页面==

> Belady异常―一当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。

==只有FIFO算法会产生Belady异常==。另外，FIFO算法虽然==实现简单==，但是该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此，==算法性能差==

##### 最近最久未使用置换算法(LRU)

最近最久未使用置换算法（LRU，least recently used):每次==淘汰的页面==是==最近最久未使用的页面==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929225316314.png" alt="image-20210929225316314" style="zoom:80%;" />

在手动做题时，若需要淘汰页面，可以逆向检查此时在内存中的几个页面号。在==逆向扫描过程中最后一个出现的页号就是要淘汰的页面。==

该算法的实现需要==专门的硬件支持==,虽然算法==性能好==,但是==实现困难,开销大==

##### 时钟置换算法(CLOCK)

最佳置换算法性能最好，但无法实现;先进先出置换算法实现简单，但算法性能差;最近最久未使用置换算法性能好，是最接近OPT算法性能的，但是实现起来需要专门的硬件支持，算法开销大。
==时钟置换算法==是一种性能和开销较均衡的算法，又称==CLOCK算法==，或==最近未用算法==（NRU，Not Recently Used)

==简单的CLOCK算法==实现方法:为每个页面设置一个==访问位==，再将内存中的页面都通过链接指针==链接成一个循环队列==。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出;如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描（第二轮扫描中一定会有访问位为0的页面，因此==简单的CLOCK算法==选择一个淘汰页面==最多会经过两轮扫描==)

改进型的时钟置换算法

**==算法规则:==**将所有可能被置换的页面排成一个循环队列
第一轮:从当前位置开始扫描到第一个（0,0）的帧用于替换。本轮扫描不修改任何标志位
第二轮:若第一轮扫描失败，则重新扫描，查找第一个（0,1）的帧用于替换。本轮将所有扫描过的帧访问位设为0
第三轮:若第二轮扫描失败，则重新扫描，查找第一个(0,0）的帧用于替换。本轮扫描不修改任何标志位
第四轮:若第三轮扫描失败，则重新扫描，查找第一个（0, 1）的帧用于替换。
由于第二轮已将所有帧的访问位设为0，因此经过第三轮、第四轮扫描一定会有一个帧被选中，因此==改进型CLOCK置换算法==选择一个淘汰页面==最多会进行四轮扫描==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929225835208.png" alt="image-20210929225835208" style="zoom:80%;" />

#### 页面分配策略

==驻留集==:指请求分页存储管理中给进程分配的物理块的集合。
在采用了虚拟存储技术的系统中，驻留集大小一般小于进程的总大小。

==固定分配:==操作系统为每个进程分配一组固定数目的物理块，在进程运行期间不再改变。即，==驻留集大小不变==
==可变分配:==先为每个进程分配一定数目的物理块，在进程运行期间，可根据情况做适当的增加或减少。即，==驻留集大小可变==

==局部置换:==发生缺页时只能选进程自己的物理块进行置换。
==全局置换:==可以将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929230023668.png" alt="image-20210929230023668" style="zoom:80%;" />

**固定分配局部置换**:系统为每个进程分配一定数量的物理块，在整个运行期间都不改变。若进程在运行中发生缺页，则只能从该进程在内存中的页面中选出一页换出，然后再调入需要的页面。这种策略的缺点是:很难在刚开始就确定应为每个进程分配多少个物理块才算合理。(采用这种策略的系统可以根据进程大小、优先级、或是根据程序员给出的参数来确定为一个进程分配的内存块数)

**可变分配全局置换**:刚开始会为每个进程分配一定数量的物理块。操作系统会保持一个空闲物理块队列。当某进程发生缺页时，从空闲物理块中取出一块分配给该进程;若已无空闲物理块，则可选择一个未锁定的页面换出外存，再将该物理块分配给缺页的进程。采用这种策略时，只要某进程发生缺页，都将获得新的物理块，仅当空闲物理块用完时，系统才选择一个未锁定的页面调出。被选择调出的页可能是系统中任何一个进程中的页，因此这个被选中的进程拥有的物理块会减少，缺页率会增加。

**可变分配局部置换**:刚开始会为每个进程分配一定数量的物理块。当某进程发生缺页时，只允许从该进程自己的物理块中选出一个进行换出外存。如果进程在运行中频繁地缺页，系统会为该进程多分配几个物理块，直至该进程缺页率趋势适当程度;反之，如果进程在运行中缺页率特别低，则可适当减少分配给该进程的物理块。

何时调入页面？

- 预调页策略:根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效。但如果提前调入的页面中大多数都没被访问过，则又是低效的。因此可以预测不久之后可能访问到的页面，将它们预先调入内存，但目前预测成功率只有50%左右。故这种策略==主要用于进程的首次调入==，由程序员指出应该先调入哪些部分。
- 请求调页策略:进程==在运行期间发现缺页时才将所缺页面调入内存==。由这种策略调入的页面一定会被访问到，但由于每次只能调入一页，而每次调页都要磁盘I/o操作，因此/O开销较大。

从何处调入页面

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929230413087.png" alt="image-20210929230413087" style="zoom:80%;" />

1. 系统拥有足够的对换区空间:页面的调入、调
   出都是在内存与对换区之间进行，这样可以保证页面的调入、调出速度很快。在进程运行前,需将进程相关的数据从文件区复制到对换区。
2. 系统缺少足够的对换区空间:凡是不会被修改
   的数据都直接从文件区调入，由于这些页面不会被修改，因此换出时不必写回磁盘，下次需要时再从文件区调入即可。对于可能被修改的部分，换出时需写回磁盘对换区，下次需要时再从对换区调入。
3. UNIX方式:运行之前进程有关的数据全部放在
   文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入。

刚刚换出的页面马上又要换入内存，刚刚换入的页面马上又要换出外存，这种频繁的页面调度行为称为==抖动==，或==颠簸==。产生抖动的==主要原因==是进程频繁访问的页面数目高于可用的物理块数（==分配给进程的物理块不够==)

- ==驻留集==:指请求分页存储管理中给进程分配的内存块的集合。
- ==工作集==:指在某段时间间隔里，进程实际访问页面的集合。

工作集大小可能小于窗口尺寸，实际应用中，操作系统可以统计进程的工作集大小，根据工作集大小给进程分配若干内存块。如:窗口尺寸为5，经过一段时间的监测发现某进程的工作集最大为3，那么说明该进程有很好的局部性，可以给这个进程分配3个以上的内存块即可满足进程的运行需要
==一般来说，驻留集大小不能小于工作集大小，否则进程运行过程中将频繁缺页。==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210929230837895.png" alt="image-20210929230837895" style="zoom:80%;" />

#### 内存映射文件

传统方法：直接访问磁盘，极不方便而且IO次数太多影响效率。

内存映射：将文件映射到内存，进程通过访问内存的方式来读写文件，既方便操作又减少了IO次数，另外还可以进行文件共享。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202155451876.png" alt="image-20211202155451876" style="zoom:80%;" />

#### 虚拟存储器性能的影响因素及改进方式

##### 核心性能指标

1. 缺页率
2. TLB命中率
3. Cache命中率
4. 页面置换速度

##### 改进方式

* 页面大小
  * 页面大：缺页率下降、但页面置换速度也下降
  * 页面小：缺页率上升、但页面置换速度也上升
* 给进程分配的页框数
  * 页框多于正常页面数量：缺页率低
  * 页框少于正常页面数量：缺页率高
* 页面置换算法
  * 直接影响缺页率
* 程序局部性
  * 影响缺页率、TLB命中率、Cache命中率
* 外存交换区读写速度
  * 影响页面置换速度

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202160524742.png" alt="image-20211202160524742" style="zoom:80%;" />

## 内存保护

* 设置上下限寄存器
* 利用重定位寄存器、界地址寄存器进行判断 

## 内存共享

内存共享通常是通过“==内存映射==”实现的,将多个进程的虚拟地址空间映射到同一片物理内存

可以是“页”映射，也可以是“段”映射

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20211202155402007.png" alt="image-20211202155402007" style="zoom:80%;" />
