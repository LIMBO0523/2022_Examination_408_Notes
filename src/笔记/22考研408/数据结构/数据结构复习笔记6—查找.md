

# 查找

静态查找表：仅关注查找速度即可

动态查找表：出了查找速度，也要关注插/删操作是否方便实现‘



查找长度———在查找运算中，需要对比关键字的次数称为查找长度

平均查找长度(ASL, Average Search Length)——所有查找过程中进行==关键字的比较次数==的==平均值==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210524205407485.png" alt="image-20210524205407485" style="zoom: 50%;" />

## 顺序查找

实现

~~~c
typedef struct{
    ElemType *elem;
    int Tablelen;
}SSTable;

int Search_Seq(SSTable ST,ElemType key){
    ST.elem[0]=key;
    int i;
    for(i=ST.Table;ST.elem[i]!=key;--i)
        return i;
}
~~~

### 效率分析

$$
ASL=\sum_{i=1}^n P_iC_i
$$

P~i~第i个数的查找概率，需要C次比较


$$
ASL_{成功}=\frac{1+2+3+……+n}{n}=\frac{n+1}{2}
$$

$$
ASL_{失败}={n+1}
$$
**==时间复杂度O(n)==**

### 优化(对有序表)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210524211951457.png" alt="image-20210524211951457" style="zoom: 50%;" />

一个成功结点的查找长度=自身所在层数

一个失败结点的查找长度=其父节点所在层数

默认情况下，各种失败情况或成功情况都等概率发生
$$
ASL_{不成功}=\frac{1+2+3+……+n+n}{n+1}=\frac{n}{2}+\frac{n}{n+1}
$$

### 优化(被查概率不相等)

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210524212639141.png" alt="image-20210524212639141" style="zoom: 50%;" />

## 折半查找

折半查找，又称“二分查找”，仅适用于==有序==的==顺序表==。

### 实现

~~~c
typedef struct{
    ElemType *elem;
    int Tablelen;
}SSTable;

int Binary_Search(SSTable L,ElemType key){
    int low=0,high=L.Tablelen-1,min;
    while(low<=high){
        mid=(low+high)/2;
        if(L.elem[mid]==key)
            return mid;
        else if(L.elem[mid]>key)
            high=mid-1;
        else
            low=mid+1
    }
    return -1;
}
~~~

### 判定树

如果当前low和high之间有==奇数个==元素，则mid分隔后，==左右两部分元素个数相等==

如果当前low和high之间有==偶数个==元素，则mid分隔后，==左半部分比右半部分少一个元素==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210528220001651.png" alt="image-20210528220001651" style="zoom: 42%;" />

==右子树结点数-左子树结点数=0或1==

折半查找的判定树==一定是平衡二叉树==

折半查找的判定树中，==只有最下面一层是不满的==

因此，元素个数为n时==树高h =⌈log~2~(n+ 1)⌉==

==时间复杂度O(log~2~n)==

## 分块查找

==分块查找==，又称==索引顺序查找==，算法过程如下:

1. 在索引表中确定待查记录所属的分块（可顺序、可折半)
2. 在块内顺序查找

若索引表中不包含目标关键字，则折半查找索引表最终停在low>high，要==在low所指分块中查找==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210524223544292.png" alt="image-20210524223544292" style="zoom:67%;" />

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210524223708803.png" alt="image-20210524223708803" style="zoom:67%;" />

## B树

### B树的定义

==B树==，又称==多路平衡查找树==，B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵==m阶B树==或为空树，或为满足如下特性的m叉树:

1. 树中每个结点至多有m棵子树，即至多含有m-1个关键字。
2. 若根结点不是终端结点，则至少有两棵子树。
3. ==除根结点外==的所有非叶结点==至少有⌈m/2⌉棵子树==，即至少含有==⌈m/2⌉-1个关键字==。
4. 所有非叶结点的结构如下:
   ![image-20210525205913057](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210525205913057.png)
   其中，K~i~ (i = 1,2,.... n)为结点的关键字，且==满足K~1~< K~2~<...< K~n~==;P~i~(i = 0,1,... n)为指向子树根结点的指针，且==指针P~i~-1所指子树中所有结点的关键字均小于K~i~，P~i~所指子树中所有结点的关键字均大于K~i~==, n(⌈m/2⌉- 1≤n≤m -1)为结点中关键字的个数。
5. 所有的==叶结点==都出现在同一层次上，并且不带信息(可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空)。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210525204621990.png" alt="image-20210525204621990" style="zoom:67%;" />

如何保证查找效率：

- m叉查找树中，规定除了根节点外，任何结点至少有==⌈m/2⌉==个分叉，即至少含有==⌈m/2⌉- 1==个关键字
- m叉查找树中，规定对于任何一个结点，其所有子树的高度都要相同。

### ==B树的高度==

注：大部分学校算B树的==高度不包括==**叶子结点(失败结点)**

最小高度——让每个结点尽可能的满，有m-1个关键字，m个分叉，则有n≤(m -1)(1+ m+ m^2^ + m^3^+ ...+ m^h-1^) = m^h^ -1，因此==h≥log~m~(n +1)==

最大高度——让各层的分叉尽可能的少，即根节点只有2个分叉，其他结点只有⌈m/2⌉个分叉各层结点至少有:第一层1、第二层2、第三层2⌈m/2⌉ ...第h层2(⌈m/2⌉)^h-2^第h+1层共有叶子结点(失败结点)2(⌈m/2⌉)^h-1^

==n个关键字的B树必有n+1个叶子结点==，则n＋1 ≥ 2(⌈m/2⌉)^h-1^，即
$$
log_m(n+1)≤h≤log_{⌈m/2⌉}(\frac{n+1}{2})+1
$$


### ==B树的插入==

5阶B树——结点关键字个数⌈m/2⌉-1≤n≤m-1即︰2≤n≤4(注:此处省略失败结点)

在插入key后，若导致原结点关键字数超过上限，则从中间位置（==⌈m/2⌉==）将其中的关键字==分为两部分==，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置（⌈m/2⌉)的结点插入原结点的父结点。若此时导致其==父结点的关键字==个数也==超过==了==上限==，则==继续==进行这种==分裂==操作，直至这个过程传到根结点为止，进而导致B树高度增l。

### ==B树的删除==

1. 若被删除关键字在==终端节点==，则直接删除该关键字（要注意节点关键字个数是否低于下限⌈m/2⌉-1)
2. 若被删除关键字在==非终端节点==，则用直接前驱或直接后继来替代被删除的关键字
   1. ​	==直接前驱==︰当前关键字==左侧指针所指子树中“最右下”的元素==
   2. ​	==直接后继==:当前关键字==右侧指针所指子树中“最左下”的元素==
3. 兄弟够借。若被删除关键字所在结点删除前的关键字个数低于下限，且与此结点右（或左〉兄弟结点的关键字个数还很宽裕，则需要调整该结点、右（或左）兄弟结点及其双亲结点(父子换位法)
4. 兄弟不够借。若被删除关键字所在结点删除前的关键字个数低于下限,且此时与该结点相邻的左、右兄弟结
   点的关键字个数均=[m/2]-1，则将关键字删除后==与左（或右〉兄弟结点==及==双亲结点中的关键字==进行==合并==
   1. 在合并过程中，双亲结点中的关键字个数会减1。若其双亲结点是根结点且关键字个数减少至0(根结点关键字个数为1时，有2棵子树），则直接将根结点删除，合并后的新结点成为根;若双亲结点不是根结点，且关键字个数减少到[m/2]-2，则又要与它自己的兄弟结点进行调整或合并操作，并重复上述步骤，直至符合B树的要求为止。

## ![image-20210525233419683](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210525233419683.png)

## B+树

一棵==m阶B+树==需满足下列条件：

1. 每个分支结点最多有m棵子树(孩子结点)。
2. 非叶根结点至少有两棵子树．其他每个分支结点至少有「m/2]棵子树。
3. ==结点的子树个数与关键字个数相等。==
4. 所有==叶结点包含全部关键字==及指向相应记录的指针，叶结点中将关键字按大小顺序排列，并且==相邻叶结点按大小顺序相互链接起来。==
5. 所有分支结点中仅包含它的各个子结点中==关键字的最大值==及指向其子结点的指针。

### B+树的查找

==B+树中，无论查找成功与否，最终一定都要走到最下面一层结点==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210528234851971.png" alt="image-20210528234851971" style="zoom:50%;" />

### B+树 vs B树

<table >
    <tr align="center">
        <td> </td>
        <td>m阶B树</td>
        <td>m阶B+树</td>
    </tr>
    <tr align="center">
        <td>类比</td>
        <td>二叉查找树的进化——>m叉查找树</td>
        <td>分块查找的进化——>多级分块查找</td>
    </tr>
    <tr align="center">
        <td>关键字与分叉</td>
        <td>n个关键字对应n+1个分叉(子树)</td>
        <td>n个关键字对应n个分叉</td>
    </tr>
    <tr align="center">
        <td>节点包含的信息</td>
        <td>所有节点都包含记录的信息</td>
        <td>只有最下层叶子结点才包含记录的信息
        	(可使树更矮)</td>
    </tr>
    <tr align="center">
        <td>查找方式</td>
        <td>不支持顺序查找。查找成功时，可能停在任何一层结点，查找速度“不稳定”</td>
        <td>支持顺序查找。查找成功或失败都会到达最下一层结点，查找速度“稳定”</td>
    </tr>
    <tr align="center">
        <td>相同点</td>
        <td colspan=2>除根节点外，最少「m/21个分叉(确保结点不要太“空”")<br>
            任何一个结点的子树都要一样高（确保“绝对平衡”)</td>
    </tr>
</table>

## 散列查找

### 散列表（Hash Table）

==散列表==(Hash Table)，又称==哈希表==。是一种数据结构，特点是∶数据元素的==关键字==与其==存储地址直接相关==。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526221330384.png" alt="image-20210526221330384" style="zoom: 60%;" />



### 处理冲突的方法

#### 拉链法

用==拉链法==（又称链接法、链地址法）处理“冲突”:==把所有“同义词”存储在一个链表中==

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526221636016.png" alt="image-20210526221636016" style="zoom:55%;" />

### 散列查找

查找长度——在查找运算中，需要===对比关键字的次数==称为查找长度

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526222909513.png" alt="image-20210526222909513" style="zoom: 60%;" />


$$
ASL_{成功}=\frac{1+2+3+1+2+1+2+1+1+2+1}{12}=1.75
$$

$$
ASL_{失败}=\frac{0+4+0+2+0+0+2+1+0+0+2+1+0}{13}=0.92
$$



==装填因子α===表中记录数/散列表长度

### 常见的散列函数

#### 除留余数法——H(key) = key % p

**散列表表长为m，取一个不大于m但最接近或等于m的==质数==p**

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526225011047.png" alt="image-20210526225011047" style="zoom: 65%;" />

####  直接定址法—— H(key)=key或H(key) = a*key + b

其中，a和b是常数。这种方法计算最简单，且不会产生冲突。它==适合关键字的分布基本连续的情况==，若关键字分布连续，空位较多，则会造成存储空间的浪费。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526225321274.png" alt="image-20210526225321274" style="zoom: 74%;" />



#### 数字分析法——选取数码分布较为均匀的若干位作为散列地址

设关键字是r进制数〈如十进制数)，而==r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀一些==，每种数码出现的机会均等;而在某些位上分布不均匀，只有某几种数码经常出现，此时可选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合，若更换了关键字，则需要重新构造新的散列函数。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526225610144.png" alt="image-20210526225610144" style="zoom: 65%;" />

#### 平方取中法――取关键字的平方值的中间几位作为散列地址。

具体取多少位要视实际情况而定。==这种方法得到的散列地址与关键字的每位都有关系==，因此使得散列地址分布比较均匀，适用于关键字的每位取值都不够均匀或均小于散列地址所需的位数。

<img src="C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526225843141.png" alt="image-20210526225843141" style="zoom:60%;" />



![image-20210526230016258](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526230016258.png)

### 处理冲突的方法

#### 开放定址法

所谓==开放定址法==，是指可存放新表项的空闲地址既向它的同义词表项开放，又向它的非同义词表项开放。

其数学递推公式为∶
$$
H_i=(H(key)+d_i)\%m
$$
i = 0,1,2..,k (k≤m -1) ,==m==表示==散列表表长==;==d~i~==为==增量序列==;i可理解为“第i次发生冲突”

==线性探测法==——d~i~=0,1,2,3,..., m-1;即发生冲突时，每次往后探测相邻的下一个单元是否为空

- 线性探测法很容易造成同义词、非同义词的“==聚集（堆积）”现象==，严重影响查找效率

==平方探测法==。当d~i~=0^2^,1^2^,-1^2^,2^2^,-2^2^,... k^2^,-k^2^时，称为平方探测法，又称==二次探测法==其中k≤m/2

- 非重点小坑︰散列表长度m必须是一个可以表示成==4j+3==的素数，才能探测到所有位置

==伪随机序列法==。d是一个伪随机序列，如d~i~= 0,5,24,11, …

==注意:采用“开放定址法”时，删除结点次能简单地将被删结点的空间置为空，否则将截断在它之后填入
散列表的同义词结点的查找路径，可以做一个“删除标记”，进行逻辑删除==

#### 再散列法（再哈希法)

除了原始的散列函数 H(key)之外，多准备几个散列函数,当散列函数冲突时，用下一个散列函数计算一个新地址，直到不冲突为止:
$$
H_i=RH_i(Key) \qquad i=1,2,3...,k
$$


![image-20210526233822855](C:\Users\LIMBO\AppData\Roaming\Typora\typora-user-images\image-20210526233822855.png)

